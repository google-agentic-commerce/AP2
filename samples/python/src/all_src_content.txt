--- Content of roles/merchant_payment_processor_agent/tools.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tools for the merchant payment processor agent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process.
"""


import logging
from typing import Any

from a2a.server.tasks.task_updater import TaskUpdater
from a2a.types import DataPart
from a2a.types import Part
from a2a.types import Task
from a2a.types import TaskState
from a2a.types import TextPart

from ap2.types.mandate import PAYMENT_MANDATE_DATA_KEY
from ap2.types.mandate import PaymentMandate
from common import artifact_utils
from common import message_utils
from common.a2a_extension_utils import EXTENSION_URI
from common.a2a_message_builder import A2aMessageBuilder
from common.payment_remote_a2a_client import PaymentRemoteA2aClient


async def initiate_payment(
    data_parts: list[dict[str, Any]],
    updater: TaskUpdater,
    current_task: Task | None,
    debug_mode: bool = False,
) -> None:
  """Handles the initiation of a payment."""
  payment_mandate = message_utils.find_data_part(
      PAYMENT_MANDATE_DATA_KEY, data_parts
  )
  if not payment_mandate:
    error_message = _create_text_parts("Missing payment_mandate.")
    await updater.failed(message=updater.new_agent_message(parts=error_message))
    return

  challenge_response = (
      message_utils.find_data_part("challenge_response", data_parts) or ""
  )
  await _handle_payment_mandate(
      PaymentMandate.model_validate(payment_mandate),
      challenge_response,
      updater,
      current_task,
      debug_mode,
  )


async def _handle_payment_mandate(
    payment_mandate: PaymentMandate,
    challenge_response: str,
    updater: TaskUpdater,
    current_task: Task | None,
    debug_mode: bool = False,
) -> None:
  """Handles a payment mandate.

  If no task is present, it initiates a transaction challenge. If a task
  requires input, it verifies the challenge response and completes the payment.

  Args:
    payment_mandate: The payment mandate containing payment details.
    challenge_response: The response to a transaction challenge, if any.
    updater: The task updater for managing task state.
    current_task: The current task, or None if it's a new payment.
    debug_mode: Whether the agent is in debug mode.
  """
  if current_task is None:
    await _raise_challenge(updater)
    return

  if current_task.status.state == TaskState.input_required:
    await _check_challenge_response_and_complete_payment(
        payment_mandate,
        challenge_response,
        updater,
        debug_mode,
    )
    return


async def _raise_challenge(
    updater: TaskUpdater,
) -> None:
  """Raises a transaction challenge.

  This challenge would normally be raised by the issuer, but we don't
  have an issuer in the demo, so we raise the challenge here. For concreteness,
  we are using an OTP challenge in this sample.

  Args:
    updater: The task updater.
  """
  challenge_data = {
      "type": "otp",
      "display_text": (
          "The payment method issuer sent a verification code to the phone "
          "number on file, please enter it below. It will be shared with the "
          "issuer so they can authorize the transaction."
          "(Demo only hint: the code is 123)"
      ),
  }
  text_part = TextPart(
      text="Please provide the challenge response to complete the payment."
  )
  data_part = DataPart(data={"challenge": challenge_data})
  message = updater.new_agent_message(
      parts=[Part(root=text_part), Part(root=data_part)]
  )
  await updater.requires_input(message=message)


async def _check_challenge_response_and_complete_payment(
    payment_mandate: PaymentMandate,
    challenge_response: str,
    updater: TaskUpdater,
    debug_mode: bool = False,
) -> None:
  """Checks the challenge response and completes the payment process.

  Checking the challenge response would be done by the issuer, but we don't
  have an issuer in the demo, so we do it here.

  Args:
    payment_mandate: The payment mandate.
    challenge_response: The challenge response.
    updater: The task updater.
    debug_mode: Whether the agent is in debug mode.
  """
  if _challenge_response_is_valid(challenge_response=challenge_response):
    await _complete_payment(payment_mandate, updater, debug_mode)
    return

  message = updater.new_agent_message(
      _create_text_parts("Challenge response incorrect.")
  )
  await updater.requires_input(message=message)


async def _complete_payment(
    payment_mandate: PaymentMandate,
    updater: TaskUpdater,
    debug_mode: bool = False,
) -> None:
  """Completes the payment process.

  Args:
    payment_mandate: The payment mandate.
    updater: The task updater.
    debug_mode: Whether the agent is in debug mode.
  """
  payment_mandate_id = (
      payment_mandate.payment_mandate_contents.payment_mandate_id
  )
  payment_credential = await _request_payment_credential(
      payment_mandate, updater, debug_mode
  )

  logging.info(
      "Calling issuer to complete payment for %s with payment credential %s...",
      payment_mandate_id,
      payment_credential,
  )
  # Call issuer to complete the payment
  success_message = updater.new_agent_message(
      parts=_create_text_parts("{'status': 'success'}")
  )
  await updater.complete(message=success_message)


def _challenge_response_is_valid(challenge_response: str) -> bool:
  """Validates the challenge response."""

  return challenge_response == "123"


async def _request_payment_credential(
    payment_mandate: PaymentMandate,
    updater: TaskUpdater,
    debug_mode: bool = False,
) -> str:
  """Sends a request to the Credentials Provider for payment credentials.

  Args:
    payment_mandate: The PaymentMandate containing payment details.
    updater: The task updater.
    debug_mode: Whether the agent is in debug mode.

  Returns:
    payment_credential: The payment credential details.
  """
  token_object = (
      payment_mandate.payment_mandate_contents.payment_response.details.get(
          "token"
      )
  )
  credentials_provider_url = token_object.get("url")

  credentials_provider = PaymentRemoteA2aClient(
      name="credentials_provider",
      base_url=credentials_provider_url,
      required_extensions={EXTENSION_URI},
  )

  message_builder = (
      A2aMessageBuilder()
      .set_context_id(updater.context_id)
      .add_text("Give me the payment method credentials for the given token.")
      .add_data(PAYMENT_MANDATE_DATA_KEY, payment_mandate.model_dump())
      .add_data("debug_mode", debug_mode)
  )
  task = await credentials_provider.send_a2a_message(message_builder.build())

  if not task.artifacts:
    raise ValueError("Failed to find the payment method data.")
  payment_credential = artifact_utils.get_first_data_part(task.artifacts)

  return payment_credential


def _create_text_parts(*texts: str) -> list[Part]:
  """Helper to create text parts."""
  return [Part(root=TextPart(text=text)) for text in texts]


--- Content of roles/merchant_payment_processor_agent/agent.json ---

{
  "name": "merchant_payment_processor_agent",
  "description": "An agent that processes card payments on behalf of a merchant.",
  "capabilities": {
      "extensions": [
        {
          "uri": "https://github.com/google-agentic-commerce/ap2/v1",
          "description": "Supports the Agent Payments Protocol.",
          "required": true
        },
        {
          "uri": "https://sample-card-network.github.io/paymentmethod/types/v1",
          "description": "Supports the Sample Card Network payment method extension",
          "required": true
        }
      ]
  },
  "skills": [
    {
      "id": "card-processor",
      "name": "Card Processor",
      "description": "Processes card payments.",
      "tags": ["payment", "card"]
    }
  ],
  "defaultInputModes": ["text/plain"],
  "defaultOutputModes": ["application/json"],
  "url": "http://localhost:8003/a2a/merchant_payment_processor_agent",
  "version": "1.0.0"
}


--- Content of roles/merchant_payment_processor_agent/agent_executor.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Agent executor for processing payments on behalf of a merchant.

This agent's role is to:
1. Complete payments, engaging with the credentials provider agent when needed.

In order to clearly demonstrate the use of the Agent Payments Protocol A2A
extension, this agent was built directly using the A2A framework.

The core logic of how an A2A agent processes requests and generates responses is
handled by an AgentExecutor. The BaseServerExecutor handles the common task of
interpreting the user's request, identifying the appropriate tool to use, and
invoking it to complete a task.
"""


from typing import Any

from . import tools
from common.base_server_executor import BaseServerExecutor
from common.system_utils import DEBUG_MODE_INSTRUCTIONS




class PaymentProcessorExecutor(BaseServerExecutor):
  """AgentExecutor for the merchant payment processor agent."""

  _system_prompt = """
    You are a payment processor agent. Your role is to process payments
    on behalf of a merchant.

    %s
  """ % DEBUG_MODE_INSTRUCTIONS

  def __init__(self, supported_extensions: list[dict[str, Any]] = None):
    """Initializes the PaymentProcessorExecutor."""
    agent_tools = [
        tools.initiate_payment,
    ]
    super().__init__(supported_extensions, agent_tools, self._system_prompt)


--- Content of roles/merchant_payment_processor_agent/__main__.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""An agent for processing payments on behalf of a merchant."""

from collections.abc import Sequence

from absl import app

from roles.merchant_payment_processor_agent.agent_executor import PaymentProcessorExecutor
from common import server

AGENT_PAYMENT_PROCESSOR_PORT = 8003

def main(argv: Sequence[str]) -> None:
  agent_card = server.load_local_agent_card(__file__)
  server.run_agent_blocking(
      port=AGENT_PAYMENT_PROCESSOR_PORT,
      agent_card=agent_card,
      executor=PaymentProcessorExecutor(agent_card.capabilities.extensions),
      rpc_url="/a2a/merchant_payment_processor_agent",
  )

if __name__ == "__main__":
  app.run(main)


--- Content of roles/merchant_payment_processor_agent/__pycache__/agent_executor.cpython-312.pyc ---



    lhQ                     N    d Z ddlmZ ddlmZ ddlmZ ddlmZ  G d de      Z	y	)
aG  Agent executor for processing payments on behalf of a merchant.

This agent's role is to:
1. Complete payments, engaging with the credentials provider agent when needed.

In order to clearly demonstrate the use of the Agent Payments Protocol A2A
extension, this agent was built directly using the A2A framework.

The core logic of how an A2A agent processes requests and generates responses is
handled by an AgentExecutor. The BaseServerExecutor handles the common task of
interpreting the user's request, identifying the appropriate tool to use, and
invoking it to complete a task.
    )Any   )tools)BaseServerExecutor)DEBUG_MODE_INSTRUCTIONSc                   D     e Zd ZdZdez  Zddeeee	f      f fd
Z
 xZS )PaymentProcessorExecutorz7AgentExecutor for the merchant payment processor agent.zp
    You are a payment processor agent. Your role is to process payments
    on behalf of a merchant.

    %s
  supported_extensionsc                 ^    t         j                  g}t        | 
  ||| j                         y)z)Initializes the PaymentProcessorExecutor.N)r   initiate_paymentsuper__init___system_prompt)selfr
   agent_tools	__class__s      i/Users/heikohotz/Projects/AP2/samples/python/src/roles/merchant_payment_processor_agent/agent_executor.pyr   z!PaymentProcessorExecutor.__init__1   s/     	K 
G);8K8KL    )N)__name__
__module____qualname____doc__r   r   listdictstrr   r   
__classcell__)r   s   @r   r	   r	   '   s8    ?
 	  .M4S#X+? M Mr   r	   N)
r   typingr    r   common.base_server_executorr   common.system_utilsr   r	    r   r   <module>r"      s'      : 7
M1 Mr   

--- Content of roles/merchant_payment_processor_agent/__pycache__/__main__.cpython-312.pyc ---



    lh                         d Z ddlmZ ddlmZ ddlmZ ddlmZ dZ	dee
   dd	fd
Zedk(  r ej                  e       y	y	)z9An agent for processing payments on behalf of a merchant.    )Sequence)app)PaymentProcessorExecutor)serveriC  argvreturnNc                     t        j                  t              }t        j                  t        |t        |j                  j                        d       y )Nz%/a2a/merchant_payment_processor_agent)port
agent_cardexecutorrpc_url)r   load_local_agent_card__file__run_agent_blockingAGENT_PAYMENT_PROCESSOR_PORTr   capabilities
extensions)r   r   s     c/Users/heikohotz/Projects/AP2/samples/python/src/roles/merchant_payment_processor_agent/__main__.pymainr      s=    ++H5*''
(?(?(J(JK5	    __main__)__doc__collections.abcr   abslr   5roles.merchant_payment_processor_agent.agent_executorr   commonr   r   strr   __name__run r   r   <module>r!      sP    @ $  Z # x}   z	#''$- r   

--- Content of roles/merchant_payment_processor_agent/__pycache__/tools.cpython-312.pyc ---



    lhY              
          d Z ddlZddlmZ ddlmZ ddlmZ ddlmZ ddlm	Z	 ddlm
Z
 dd	lmZ dd
lm
Z
 ddlmZ ddlmZ dd
lmZ ddlmZ ddlmZ ddlmZ 	 d!deeeef      dede	dz  deddf
dZ	 d!dededede	dz  deddfdZdeddfdZ	 d!dededededdf
dZ	 d!dedededdfdZ dedefdZ!	 d!dedededefdZ"dedee   fd Z#y)"zTools for the merchant payment processor agent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process.
    N)Any)TaskUpdater)DataPart)Part)Task)	TaskState)TextPart)PAYMENT_MANDATE_DATA_KEY)PaymentMandate)artifact_utils)
message_utils)
EXTENSION_URI)A2aMessageBuilder)PaymentRemoteA2aClient
data_partsupdatercurrent_task
debug_modereturnc                 @  K   t        j                  t        |       }|s6t        d      }|j	                  |j                  |             d{    yt        j                  d|       xs d}t
        t        j                  |      ||||       d{    y7 J7 w)z$Handles the initiation of a payment.zMissing payment_mandate.partsmessageNchallenge_response )	r
   find_data_partr
   _create_text_partsfailednew_agent_message_handle_payment_mandater   model_validate)r   r   r   r   payment_mandate
error_messager   s          `/Users/heikohotz/Projects/AP2/samples/python/src/roles/merchant_payment_processor_agent/tools.pyinitiate_paymentr&   )   s      "00
/ 
&'ABM
..!:!:!:!O.
PPP
 ""#7DJ  	 ##O4
	  
 Qs%   A
BBABBBBr#   r   c                    K   |t        |       d{    y|j                  j                  t        j                  k(  rt        | |||       d{    yy7 D7 w)a  Handles a payment mandate.

  If no task is present, it initiates a transaction challenge. If a task
  requires input, it verifies the challenge response and completes the payment.

  Args:
    payment_mandate: The payment mandate containing payment details.
    challenge_response: The response to a transaction challenge, if any.
    updater: The task updater for managing task state.
    current_task: The current task, or None if it's a new payment.
    debug_mode: Whether the agent is in debug mode.
  N)_raise_challengestatusstater   input_required._check_challenge_response_and_complete_payment)r#   r   r   r   r   s        r%   r!   r!   D   sl     & 
7
###
)":"::
8	    ; $s!   AA=AAAAc                    K   ddd}t        d      }t        d|i      }| j                  t        |      t        |      g	      }| j	                  |
       d{    y7 w)a  Raises a transaction challenge.

  This challenge would normally be raised by the issuer, but we don't
  have an issuer in the demo, so we raise the challenge here. For concreteness,
  we are using an OTP challenge in this sample.

  Args:
    updater: The task updater.
  otpzThe payment method issuer sent a verification code to the phone number on file, please enter it below. It will be shared with the issuer so they can authorize the transaction.(Demo only hint: the code is 123))typedisplay_textz>Please provide the challenge response to complete the payment.text	challenge)datarootr   r   N)r	   r   r    r   requires_input)r   challenge_data	text_part	data_partr   s        r%   r(   r(   e   sw      .. K) [.9:)%%
y
!4Y#78 
& 
' 	w///s   AA'A% A'c                    K   t        |      rt        | ||       d{    y|j                  t        d            }|j	                  |       d{    y7 :7 w)av  Checks the challenge response and completes the payment process.

  Checking the challenge response would be done by the issuer, but we don't
  have an issuer in the demo, so we do it here.

  Args:
    payment_mandate: The payment mandate.
    challenge_response: The challenge response.
    updater: The task updater.
    debug_mode: Whether the agent is in debug mode.
  r   NzChallenge response incorrect.r   )_challenge_response_is_valid_complete_paymentr    r   r7   )r#   r   r   r   r   s        r%   r,   r,      sd     " "5GH
OWj
AAA
%%89
' 	w///
 B 0s!   AA4AAAAc                   K   | j                   j                  }t        | ||       d{   }t        j                  d||       |j                  t
        d            }|j                  |       d{    y7 Q7 w)zCompletes the payment process.

  Args:
    payment_mandate: The payment mandate.
    updater: The task updater.
    debug_mode: Whether the agent is in debug mode.
  NzGCalling issuer to complete payment for %s with payment credential %s...z{'status': 'success'}r   r   )payment_mandate_contentspayment_mandate_id_request_payment_credentiallogginginfor    r   complete)r#   r   r   rA   payment_credentialsuccess_messages         r%   r>   r>      s      ..AA  9w
  
,,O --67 . / 	111 2s"   'A?A;AA?5A=6A?=A?c                     | dk(  S )z!Validates the challenge response.123 r<   s    r%   r=   r=      s     
u	$$    c                 :  K   | j                   j                  j                  j                  d      }|j                  d      }t	        d|t
        h      }t
               j                  |j                        j                  d      j                  t        | j                               j                  d|      }|j                  |j                                d{   }|j                  st!        d      t#        j$                  |j                        }|S 7 <w)	a+  Sends a request to the Credentials Provider for payment credentials.

  Args:
    payment_mandate: The PaymentMandate containing payment details.
    updater: The task updater.
    debug_mode: Whether the agent is in debug mode.

  Returns:
    payment_credential: The payment credential details.
  tokenurlcredentials_provider)namebase_urlrequired_extensionsz;Give me the payment method credentials for the given token.r   Nz'Failed to find the payment method data.)r@   payment_responsedetailsgetr   r   r   set_context_id
context_idadd_textadd_datar
   
model_dumpsend_a2a_messagebuild	artifacts
ValueErrorr   get_first_data_part)	r#   r   r   token_objectcredentials_provider_urlrO   message_buildertaskrF   s	            r%   rB   rB      s       ..??GGKK
 
 *--e4/!'(/ ~g(()xMNx(/*D*D*FGxj)  $44_5J5J5LM	M$	

>
??%99$..I	
 
Ns   CDD=Dtextsc                  T    | D cg c]  }t        t        |             c}S c c}w )zHelper to create text parts.r1   r5   )r   r	   )rd   r2   s     r%   r   r      s$    5:	;UT$H$'
(U	;;	;s   %)F)$__doc__rC   typingr   a2a.server.tasks.task_updaterr   	a2a.typesr   r   r   r   r	   ap2.types.mandater
   r   commonr   r
   common.a2a_extension_utilsr   common.a2a_message_builderr    common.payment_remote_a2a_clientr   listdictstrboolr&   r!   r(   r,   r>   r=   rB   r   rJ   rK   r%   <module>rs      s     5      6 , !   4 8 C 	T#s(^$
 + 	
 
@ #  +	
  

B0
0	0F 	0#00 0 	0
 
0< 2#2
2 2 
	2>%S %T % )#)
) ) 		)X<s <tDz <rK   

--- Content of roles/shopping_agent/tools.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tools used by the Shopping Agent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process, such as updating a cart or initiating payment.
"""

from datetime import datetime
from datetime import timezone
import uuid

from a2a.types import Artifact
from google.adk.tools.tool_context import ToolContext

from .remote_agents import credentials_provider_client
from .remote_agents import merchant_agent_client
from ap2.types.contact_picker import ContactAddress
from ap2.types.mandate import CART_MANDATE_DATA_KEY
from ap2.types.mandate import CartMandate
from ap2.types.mandate import PAYMENT_MANDATE_DATA_KEY
from ap2.types.mandate import PaymentMandate
from ap2.types.mandate import PaymentMandateContents
from ap2.types.payment_request import PaymentResponse
from common import artifact_utils
from common.a2a_message_builder import A2aMessageBuilder


async def update_cart(
    shipping_address: ContactAddress,
    tool_context: ToolContext,
    debug_mode: bool = False,
) -> str:
  """Notifies the merchant agent of a shipping address selection for a cart.

  Args:
    shipping_address: The user's selected shipping address.
    tool_context: The ADK supplied tool context.
    debug_mode: Whether the agent is in debug mode.

  Returns:
    The updated CartMandate.
  """
  chosen_cart_id = tool_context.state["chosen_cart_id"]
  if not chosen_cart_id:
    raise RuntimeError("No chosen cart mandate found in tool context state.")

  message = (
      A2aMessageBuilder()
      .set_context_id(tool_context.state["shopping_context_id"])
      .add_text("Update the cart with the user's shipping address.")
      .add_data("cart_id", chosen_cart_id)
      .add_data("shipping_address", shipping_address)
      .add_data("shopping_agent_id", "trusted_shopping_agent")
      .add_data("debug_mode", debug_mode)
      .build()
  )
  task = await merchant_agent_client.send_a2a_message(message)

  updated_cart_mandate = artifact_utils.only(
      _parse_cart_mandates(task.artifacts)
  )

  tool_context.state["cart_mandate"] = updated_cart_mandate
  tool_context.state["shipping_address"] = shipping_address

  return updated_cart_mandate


async def initiate_payment(tool_context: ToolContext, debug_mode: bool = False):
  """Initiates a payment using the payment mandate from state.

  Args:
    tool_context: The ADK supplied tool context.
    debug_mode: Whether the agent is in debug mode.

  Returns:
    The status of the payment initiation.
  """
  payment_mandate = tool_context.state["signed_payment_mandate"]
  if not payment_mandate:
    raise RuntimeError("No signed payment mandate found in tool context state.")
  risk_data = tool_context.state["risk_data"]
  if not risk_data:
    raise RuntimeError("No risk data found in tool context state.")

  outgoing_message_builder = (
      A2aMessageBuilder()
      .set_context_id(tool_context.state["shopping_context_id"])
      .add_text("Initiate a payment")
      .add_data(PAYMENT_MANDATE_DATA_KEY, payment_mandate)
      .add_data("risk_data", risk_data)
      .add_data("shopping_agent_id", "trusted_shopping_agent")
      .add_data("debug_mode", debug_mode)
      .build()
  )
  task = await merchant_agent_client.send_a2a_message(outgoing_message_builder)
  tool_context.state["initiate_payment_task_id"] = task.id
  return task.status


async def initiate_payment_with_otp(
    challenge_response: str, tool_context: ToolContext, debug_mode: bool = False
):
  """Initiates a payment using the payment mandate from state and a

    challenge response. In our sample, the challenge response is a one-time
    password (OTP) sent to the user.

  Args:
    challenge_response: The challenge response.
    tool_context: The ADK supplied tool context.
    debug_mode: Whether the agent is in debug mode.

  Returns:
    The status of the payment initiation.
  """
  payment_mandate = tool_context.state["signed_payment_mandate"]
  if not payment_mandate:
    raise RuntimeError("No signed payment mandate found in tool context state.")
  risk_data = tool_context.state["risk_data"]
  if not risk_data:
    raise RuntimeError("No risk data found in tool context state.")

  outgoing_message_builder = (
      A2aMessageBuilder()
      .set_context_id(tool_context.state["shopping_context_id"])
      .set_task_id(tool_context.state["initiate_payment_task_id"])
      .add_text("Initiate a payment. Include the challenge response.")
      .add_data(PAYMENT_MANDATE_DATA_KEY, payment_mandate)
      .add_data("shopping_agent_id", "trusted_shopping_agent")
      .add_data("challenge_response", challenge_response)
      .add_data("risk_data", risk_data)
      .add_data("debug_mode", debug_mode)
      .build()
  )

  task = await merchant_agent_client.send_a2a_message(outgoing_message_builder)
  return task.status


def create_payment_mandate(
    payment_method_alias: str,
    user_email: str,
    tool_context: ToolContext,
) -> str:
  """Creates a payment mandate and stores it in state.

  Args:
    payment_method_alias: The payment method alias.
    user_email: The user's email address.
    tool_context: The ADK supplied tool context.

  Returns:
    The payment mandate.
  """
  cart_mandate = tool_context.state["cart_mandate"]

  payment_request = cart_mandate.contents.payment_request
  shipping_address = tool_context.state["shipping_address"]
  payment_response = PaymentResponse(
      request_id=payment_request.details.id,
      method_name="CARD",
      details={
          "token": tool_context.state["payment_credential_token"],
      },
      shipping_address=shipping_address,
      payer_email=user_email,
  )

  payment_mandate = PaymentMandate(
      payment_mandate_contents=PaymentMandateContents(
          payment_mandate_id=uuid.uuid4().hex,
          timestamp=datetime.now(timezone.utc).isoformat(),
          payment_details_id=payment_request.details.id,
          payment_details_total=payment_request.details.total,
          payment_response=payment_response,
          merchant_agent=cart_mandate.contents.merchant_name,
      ),
  )

  tool_context.state["payment_mandate"] = payment_mandate
  return payment_mandate


def sign_mandates_on_user_device(tool_context: ToolContext) -> str:
  """Simulates signing the transaction details on a user's secure device.

  This function represents the step where the final transaction details,
  including hashes of the cart and payment mandates, would be sent to a
  secure hardware element on the user's device (e.g., Secure Enclave) to be
  cryptographically signed with the user's private key.

  Note: This is a placeholder implementation. It does not perform any actual
  cryptographic operations. It simulates the creation of a signature by
  concatenating the mandate hashes.

  Args:
      tool_context: The context object used for state management. It is expected
        to contain the `payment_mandate` and `cart_mandate`.

  Returns:
      A string representing the simulated user authorization signature (JWT).
  """
  payment_mandate: PaymentMandate = tool_context.state["payment_mandate"]
  cart_mandate: CartMandate = tool_context.state["cart_mandate"]
  cart_mandate_hash = _generate_cart_mandate_hash(cart_mandate)
  payment_mandate_hash = _generate_payment_mandate_hash(
      payment_mandate.payment_mandate_contents
  )
  # A JWT containing the user's digital signature to authorize the transaction.
  # The payload uses hashes to bind the signature to the specific cart and
  # payment details, and includes a nonce to prevent replay attacks.
  payment_mandate.user_authorization = (
      cart_mandate_hash + "_" + payment_mandate_hash
  )
  tool_context.state["signed_payment_mandate"] = payment_mandate
  return payment_mandate.user_authorization


async def send_signed_payment_mandate_to_credentials_provider(
    tool_context: ToolContext,
    debug_mode: bool = False,
) -> str:
  """Sends the signed payment mandate to the credentials provider.

  Args:
    tool_context: The ADK supplied tool context.
    debug_mode: Whether the agent is in debug mode.
  """
  payment_mandate = tool_context.state["signed_payment_mandate"]
  if not payment_mandate:
    raise RuntimeError("No signed payment mandate found in tool context state.")
  risk_data = tool_context.state["risk_data"]
  if not risk_data:
    raise RuntimeError("No risk data found in tool context state.")
  message = (
      A2aMessageBuilder()
      .set_context_id(tool_context.state["shopping_context_id"])
      .add_text("This is the signed payment mandate")
      .add_data(PAYMENT_MANDATE_DATA_KEY, payment_mandate)
      .add_data("risk_data", risk_data)
      .add_data("debug_mode", debug_mode)
      .build()
  )
  return await credentials_provider_client.send_a2a_message(message)


def _generate_cart_mandate_hash(cart_mandate: CartMandate) -> str:
  """Generates a cryptographic hash of the CartMandate.

  This hash serves as a tamper-proof reference to the specific merchant-signed
  cart offer that the user has approved.

  Note: This is a placeholder implementation for development. A real
  implementation must use a secure hashing algorithm (e.g., SHA-256) on the
  canonical representation of the CartMandate object.

  Args:
      cart_mandate: The complete CartMandate object, including the merchant's
        authorization.

  Returns:
      A string representing the hash of the cart mandate.
  """
  return "fake_cart_mandate_hash_" + cart_mandate.contents.id


def _generate_payment_mandate_hash(
    payment_mandate_contents: PaymentMandateContents,
) -> str:
  """Generates a cryptographic hash of the PaymentMandateContents.

  This hash creates a tamper-proof reference to the specific payment details
  the user is about to authorize.

  Note: This is a placeholder implementation for development. A real
  implementation must use a secure hashing algorithm (e.g., SHA-256) on the
  canonical representation of the PaymentMandateContents object.

  Args:
      payment_mandate_contents: The payment mandate contents to hash.

  Returns:
      A string representing the hash of the payment mandate contents.
  """
  return (
      "fake_payment_mandate_hash_" + payment_mandate_contents.payment_mandate_id
  )


def _parse_cart_mandates(artifacts: list[Artifact]) -> list[CartMandate]:
  """Parses a list of artifacts into a list of CartMandate objects."""
  return artifact_utils.find_canonical_objects(
      artifacts, CART_MANDATE_DATA_KEY, CartMandate
  )


--- Content of roles/shopping_agent/__init__.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""The shopping agent module."""

from . import agent


--- Content of roles/shopping_agent/remote_agents.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Clients used by the shopping agent to communicate with remote agents.

Clients request activation of the Agent Payments Protocol extension by including
the X-A2A-Extensions header in each HTTP request.

This registry serves as the initial allowlist of remote agents that the shopping
agent trusts.
"""

from common.a2a_extension_utils import EXTENSION_URI
from common.payment_remote_a2a_client import PaymentRemoteA2aClient


credentials_provider_client = PaymentRemoteA2aClient(
    name="credentials_provider",
    base_url="http://localhost:8002/a2a/credentials_provider",
    required_extensions={
        EXTENSION_URI,
    },
)


merchant_agent_client = PaymentRemoteA2aClient(
    name="merchant_agent",
    base_url="http://localhost:8001/a2a/merchant_agent",
    required_extensions={
        EXTENSION_URI,
    },
)


--- Content of roles/shopping_agent/agent.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A shopping agent.

The shopping agent's role is to engage with a user to:
1. Find products offered by merchants that fulfills the user's shopping intent.
2. Help complete the purchase of their chosen items.

The Google ADK powers this shopping agent, chosen for its simplicity and
efficiency in developing robust LLM agents. 
"""

from . import tools
from .subagents.payment_method_collector.agent import payment_method_collector
from .subagents.shipping_address_collector.agent import shipping_address_collector
from .subagents.shopper.agent import shopper
from common.retrying_llm_agent import RetryingLlmAgent
from common.system_utils import DEBUG_MODE_INSTRUCTIONS


root_agent = RetryingLlmAgent(
    max_retries=5,
    model="gemini-2.5-flash",
    name="root_agent",
    instruction="""
          You are a shopping agent responsible for helping users find and
          purchase products from merchants.

          Follow these instructions, depending upon the scenario:

    %s

          Follow these instructions, depending upon the scenario:

          Scenario 1:
          The user asks to buy or shop for something.
          1. Delegate to the `shopper` agent to collect the products the user
             is interested in purchasing. The `shopper` agent will return a
             message indicating if the chosen cart mandate is ready or not.
          2. Once a success message is received, delegate to the
            `shipping_address_collector` agent to collect the user's shipping
            address.
          3. The shipping_address_collector agent will return the user's
             shipping address. Display the shipping address to the user.
          4. Once you have the shipping address, call the `update_cart` tool to
             update the cart. You will receive a new, signed `CartMandate`
             object.
          5. Delegate to the `payment_method_collector` agent to collect the
             user's payment method.
          6. The `payment_method_collector` agent will return the user's
             payment method alias.
          7. Send this message separately to the user:
               'This is where you would be redirected to a trusted surface to
               confirm the purchase.'
               'But this is a demo, so you can confirm your purchase here.'
          8. Call the `create_payment_mandate` tool to create a payment mandate.
          9. Present to the user the final cart contents including price,
               shipping, tax, total price, how long the cart is valid for (in a
               human-readable format) and how long it can be refunded (in a
               human-readable format). In a second block, show the shipping
               address. Format it all nicely. In a third block, show the user's
               payment method alias. Format it nicely.
          10. Confirm with the user they want to purchase the selected item
              using the selected form of payment.
          11. When the user confirms purchase call the following tools in order:
             a. `sign_mandates_on_user_device`
             b. `send_signed_payment_mandate_to_credentials_provider`
          12. Initiate the payment by calling the `initiate_payment` tool.
          13. If prompted for an OTP, relay the OTP request to the user.
              Do not ask the user for anything other than the OTP request.
              Once you have an challenge response, display the display_text
              from it and then call the `initiate_payment_with_otp`
              tool to retry the payment. Surface the result to the user.
          14. If the response is a success or confirmation, create a block of
              text titled 'Payment Receipt'. Ensure its contents includes
              price, shipping, tax and total price. In a second block, show the
              shipping address. Format it all nicely. In a third block, show the
              user's payment method alias. Format it nicely and give it to the
              user.

         Scenario 2:
         The user first wants you to describe all the data passed between you,
         tools, and other agents before starting with their shopping prompt.
         1. Listen to the user's request for describing the process you are
            following and the data passed between you, tools, and other agents.
            Describe the process you are following. Share data and tools used.
            Anytime you reach out to other agents, ask them to describe the data
            they are receiving and sending as well as the tools they are using.
            Be sure to include which agent is currently speaking to the user.
         2. Follow the instructions for Scenario 1 once the user confirms they
            want to start with their shopping prompt.

         Scenario 3:
         The users ask you do to anything else.
          1. Respond to the user with this message:
             "Hi, I'm your shopping assistant. How can I help you?  For example,
             you can say 'I want to buy a pair of shoes'"
          """ % DEBUG_MODE_INSTRUCTIONS,
    tools=[
        tools.create_payment_mandate,
        tools.initiate_payment,
        tools.initiate_payment_with_otp,
        tools.send_signed_payment_mandate_to_credentials_provider,
        tools.sign_mandates_on_user_device,
        tools.update_cart,
    ],
    sub_agents=[
        shopper,
        shipping_address_collector,
        payment_method_collector,
    ],
)


--- Content of roles/shopping_agent/subagents/shopper/tools.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tools used by the shopper subagent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process.
"""

from datetime import datetime
from datetime import timedelta
from datetime import timezone

from a2a.types import Artifact
from google.adk.tools.tool_context import ToolContext

from ap2.types.mandate import CART_MANDATE_DATA_KEY
from ap2.types.mandate import CartMandate
from ap2.types.mandate import INTENT_MANDATE_DATA_KEY
from ap2.types.mandate import IntentMandate
from common.a2a_message_builder import A2aMessageBuilder
from common.artifact_utils import find_canonical_objects
from roles.shopping_agent.remote_agents import merchant_agent_client


def create_intent_mandate(
    natural_language_description: str,
    user_cart_confirmation_required: bool,
    merchants: list[str],
    skus: list[str],
    requires_refundability: bool,
    tool_context: ToolContext,
) -> IntentMandate:
  """Creates an IntentMandate object.

  Args:
    natural_language_description: The description of the user's intent.
    user_cart_confirmation_required: If the user must confirm the cart.
    merchants: A list of allowed merchants.
    skus: A list of allowed SKUs.
    requires_refundability: If the items must be refundable.
    tool_context: The ADK supplied tool context.

  Returns:
    An IntentMandate object valid for 1 day.
  """
  intent_mandate = IntentMandate(
      natural_language_description=natural_language_description,
      user_cart_confirmation_required=user_cart_confirmation_required,
      merchants=merchants,
      skus=skus,
      requires_refundability=requires_refundability,
      intent_expiry=(
          datetime.now(timezone.utc) + timedelta(days=1)
      ).isoformat(),
  )
  tool_context.state["intent_mandate"] = intent_mandate
  return intent_mandate


async def find_products(
    tool_context: ToolContext, debug_mode: bool = False
) -> list[CartMandate]:
  """Calls the merchant agent to find products matching the user's intent.

  Args:
    tool_context: The ADK supplied tool context.
    debug_mode: Whether the agent is in debug mode.

  Returns:
    A list of CartMandate objects.

  Raises:
    RuntimeError: If the merchant agent fails to provide products.
  """
  intent_mandate = tool_context.state["intent_mandate"]
  if not intent_mandate:
    raise RuntimeError("No IntentMandate found in tool context state.")
  risk_data = _collect_risk_data(tool_context)
  if not risk_data:
    raise RuntimeError("No risk data found in tool context state.")
  message = (
      A2aMessageBuilder()
      .add_text("Find products that match the user's IntentMandate.")
      .add_data(INTENT_MANDATE_DATA_KEY, intent_mandate.model_dump())
      .add_data("risk_data", risk_data)
      .add_data("debug_mode", debug_mode)
      .add_data("shopping_agent_id", "trusted_shopping_agent")
      .build()
  )
  task = await merchant_agent_client.send_a2a_message(message)

  if task.status.state != "completed":
    raise RuntimeError(f"Failed to find products: {task.status}")

  tool_context.state["shopping_context_id"] = task.context_id
  cart_mandates = _parse_cart_mandates(task.artifacts)
  tool_context.state["cart_mandates"] = cart_mandates
  return cart_mandates


def update_chosen_cart_mandate(cart_id: str, tool_context: ToolContext) -> str:
  """Updates the chosen CartMandate in the tool context state.

  Args:
    cart_id: The ID of the chosen cart.
    tool_context: The ADK supplied tool context.
  """
  cart_mandates: list[CartMandate] = tool_context.state.get("cart_mandates", [])
  for cart in cart_mandates:
    print(
        f"Checking cart with ID: {cart.contents.id} with chosen ID: {cart_id}"
    )
    if cart.contents.id == cart_id:
      tool_context.state["chosen_cart_id"] = cart_id
      return f"CartMandate with ID {cart_id} selected."
  return f"CartMandate with ID {cart_id} not found."


def _parse_cart_mandates(artifacts: list[Artifact]) -> list[CartMandate]:
  """Parses a list of artifacts into a list of CartMandate objects."""
  return find_canonical_objects(artifacts, CART_MANDATE_DATA_KEY, CartMandate)


def _collect_risk_data(tool_context: ToolContext) -> dict:
  """Creates a risk_data in the tool_context."""
  # This is a fake risk data for demonstration purposes.
  risk_data = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...fake_risk_data"
  tool_context.state["risk_data"] = risk_data
  return risk_data


--- Content of roles/shopping_agent/subagents/shopper/__init__.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Shopper Agent."""

from . import agent


--- Content of roles/shopping_agent/subagents/shopper/agent.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""An agent responsible for helping the user shop for products.

Once the agent has clarified the user's purchase intent, it constructs an
IntentMandate object encapsulating this information.  The IntentMandate is sent
to the merchant agent to find relevant products.

In this sample, the merchant agent presents items for purchase in the form of
multiple CartMandate objects, assuming the user will select one of the options.

This is just one of many possible approaches.
"""

from . import tools
from common.retrying_llm_agent import RetryingLlmAgent
from common.system_utils import DEBUG_MODE_INSTRUCTIONS


shopper = RetryingLlmAgent(
    model="gemini-2.5-flash",
    name="shopper",
    max_retries=5,
    instruction="""
    You are an agent responsible for helping the user shop for products.

    %s

    When asked to complete a task, follow these instructions:
    2. Find out what the user is interested in purchasing.
    2. Ask clarifying questions one at a time to understand their needs fully.
      The shopping agent delegates responsibility for helping the user shop for
      products to this subagent. Help the user craft an IntentMandate that will
      be used to find relevant products for their purchase. Reason about the
      user's instructions and the information needed for the IntentMandate. The
      IntentMandate will be shown back to the user for confirmation so it's okay
      to make reasonable assumptions about the IntentMandate criteria initially.
      For example, inquire about:
        - A detailed description of the item.
        - Any preferred merchants or specific SKUs.
        - Whether the item needs to be refundable.
    3. After you have gathered what you believe is sufficient information,
      use the 'create_intent_mandate' tool with the collected information
      (user's description, and any other details they provided). Do not include
      any user guidance on price in the intent mandate. Use user's preferene for
      the price as a filter when recommending products for the user to select
      from.
    4. Present the IntentMandate to the user in a clear, well-formatted summary.
      Start with the statement: "Please confirm the following details for your
      purchase. Note that this information will be shared with the merchant."
      And then has a row space and a breakdown of the details:
        Item Description: The natural_language_description. Never include any
          user guidance on price in the intent mandate.
        User Confirmation Required: A human-readable version of
        user_cart_confirmation_required (e.g., 'Yes', 'No').
        Merchants: A comma-separated list of merchants, or
        'Any' if not specified.
        SKUs: A comma-separated list of SKUs, or
        'Any' if not specified.
        Refundable: 'Yes' or 'No'.
        Expires: Convert the intent_expiry timestamp into a
        human-readable relative time (e.g., "in 1 hour", "in 2 days").

      After the breakdown, leave a blank line and end with: "Shall I proceed?"
    5. Once the user confirms, use the 'find_products' tool. It will
      return a list of `CartMandate` objects.
    6. For each CartMandate object in the list, create a visually distinct entry
      that includes the following details from the object:
          Item: Display the item_name clearly and in bold.
          Price: Present the total_price with the currency. Format the price
            with commas, and use the currency symbol (e.g., "$1,234.56").
          Expires: Convert the cart_expiry into a human-readable format
            (e.g., "in 2 hours," "by tomorrow at 5 PM").
          Refund Period: Convert the refund_period into a human-readable format
            (e.g., "30 days," "14 days").
      Present these details to the user in a clear way. If there are more than
      one CartMandate object, present them as a numbered list.
      At the bottom, present Sold by: Show the merchant_name
      associate the first Transaction.
      Ensure the cart you think matches the user's intent the most is presented
      at the top of the list. Add a 2-3 line summary of why you recommended the
      first option to the user.
    7. Ask the user which item they would like to purchase.
    8. After they choose, call the update_chosen_cart_mandate tool with the
      appropriate cart ID.
    9. Monitor the tool's output. If the cart ID is not found, you must inform
      the user and prompt them to try again. If the selection is successful,
      signal a successful update and hand off the process to the root_agent.
    """ % DEBUG_MODE_INSTRUCTIONS,
    tools=[
        tools.create_intent_mandate,
        tools.find_products,
        tools.update_chosen_cart_mandate,
    ],
)


--- Content of roles/shopping_agent/subagents/shopper/__pycache__/agent.cpython-312.pyc ---



    lh              	           d Z ddlmZ ddlmZ ddlmZ  edddd	ez  ej                  ej                  ej                  g
      Z
y)a  An agent responsible for helping the user shop for products.

Once the agent has clarified the user's purchase intent, it constructs an
IntentMandate object encapsulating this information.  The IntentMandate is sent
to the merchant agent to find relevant products.

In this sample, the merchant agent presents items for purchase in the form of
multiple CartMandate objects, assuming the user will select one of the options.

This is just one of many possible approaches.
   )tools    )RetryingLlmAgent)DEBUG_MODE_INSTRUCTIONSzgemini-2.5-flashshopper   a!  
    You are an agent responsible for helping the user shop for products.

    %s

    When asked to complete a task, follow these instructions:
    2. Find out what the user is interested in purchasing.
    2. Ask clarifying questions one at a time to understand their needs fully.
      The shopping agent delegates responsibility for helping the user shop for
      products to this subagent. Help the user craft an IntentMandate that will
      be used to find relevant products for their purchase. Reason about the
      user's instructions and the information needed for the IntentMandate. The
      IntentMandate will be shown back to the user for confirmation so it's okay
      to make reasonable assumptions about the IntentMandate criteria initially.
      For example, inquire about:
        - A detailed description of the item.
        - Any preferred merchants or specific SKUs.
        - Whether the item needs to be refundable.
    3. After you have gathered what you believe is sufficient information,
      use the 'create_intent_mandate' tool with the collected information
      (user's description, and any other details they provided). Do not include
      any user guidance on price in the intent mandate. Use user's preferene for
      the price as a filter when recommending products for the user to select
      from.
    4. Present the IntentMandate to the user in a clear, well-formatted summary.
      Start with the statement: "Please confirm the following details for your
      purchase. Note that this information will be shared with the merchant."
      And then has a row space and a breakdown of the details:
        Item Description: The natural_language_description. Never include any
          user guidance on price in the intent mandate.
        User Confirmation Required: A human-readable version of
        user_cart_confirmation_required (e.g., 'Yes', 'No').
        Merchants: A comma-separated list of merchants, or
        'Any' if not specified.
        SKUs: A comma-separated list of SKUs, or
        'Any' if not specified.
        Refundable: 'Yes' or 'No'.
        Expires: Convert the intent_expiry timestamp into a
        human-readable relative time (e.g., "in 1 hour", "in 2 days").

      After the breakdown, leave a blank line and end with: "Shall I proceed?"
    5. Once the user confirms, use the 'find_products' tool. It will
      return a list of `CartMandate` objects.
    6. For each CartMandate object in the list, create a visually distinct entry
      that includes the following details from the object:
          Item: Display the item_name clearly and in bold.
          Price: Present the total_price with the currency. Format the price
            with commas, and use the currency symbol (e.g., "$1,234.56").
          Expires: Convert the cart_expiry into a human-readable format
            (e.g., "in 2 hours," "by tomorrow at 5 PM").
          Refund Period: Convert the refund_period into a human-readable format
            (e.g., "30 days," "14 days").
      Present these details to the user in a clear way. If there are more than
      one CartMandate object, present them as a numbered list.
      At the bottom, present Sold by: Show the merchant_name
      associate the first Transaction.
      Ensure the cart you think matches the user's intent the most is presented
      at the top of the list. Add a 2-3 line summary of why you recommended the
      first option to the user.
    7. Ask the user which item they would like to purchase.
    8. After they choose, call the update_chosen_cart_mandate tool with the
      appropriate cart ID.
    9. Monitor the tool's output. If the cart ID is not found, you must inform
      the user and prompt them to try again. If the selection is successful,
      signal a successful update and hand off the process to the root_agent.
    )modelnamemax_retriesinstructionr   N)__doc__ r   common.retrying_llm_agentr   common.system_utilsr   create_intent_mandate
find_productsupdate_chosen_cart_mandater        `/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent/subagents/shopper/agent.py<module>r      sb   
  6 7 
	AB "CA"F 	##

((MKr   

--- Content of roles/shopping_agent/subagents/shopper/__pycache__/__init__.cpython-312.pyc ---



    lhj                         d Z ddlmZ y)zShopper Agent.   )agentN)__doc__ r        c/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent/subagents/shopper/__init__.py<module>r	      s
     r   

--- Content of roles/shopping_agent/subagents/shopper/__pycache__/tools.cpython-312.pyc ---



    lh                     &   d Z ddlmZ ddlmZ ddlmZ ddlmZ ddlmZ ddlm	Z	 ddlm
Z
 dd	lmZ dd
lmZ ddl
mZ ddlmZ dd
lmZ dededee   dee   dededefdZ	 ddededee
   fdZdededefdZdee   dee
   fdZdedefdZy)zTools used by the shopper subagent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process.
    )datetime)	timedelta)timezone)Artifact)ToolContext)CART_MANDATE_DATA_KEY)CartMandate)INTENT_MANDATE_DATA_KEY)
IntentMandate)A2aMessageBuilder)find_canonical_objects)merchant_agent_clientnatural_language_descriptionuser_cart_confirmation_required	merchantsskusrequires_refundabilitytool_contextreturnc                     t        | ||||t        j                  t        j                        t        d      z   j
                               }||j                  d<   |S )a  Creates an IntentMandate object.

  Args:
    natural_language_description: The description of the user's intent.
    user_cart_confirmation_required: If the user must confirm the cart.
    merchants: A list of allowed merchants.
    skus: A list of allowed SKUs.
    requires_refundability: If the items must be refundable.
    tool_context: The ADK supplied tool context.

  Returns:
    An IntentMandate object valid for 1 day.
     )days)r   r   r   r   r   
intent_expiryintent_mandate)r   r   nowr   utcr   	isoformatstate)r   r   r   r   r   r   r   s          `/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent/subagents/shopper/tools.pycreate_intent_mandater    %   sW    * !#?&E3
,,x||
$ya'8
8		. *8,%&	    
debug_modec                   K   | j                   d   }|st        d      t        |       }|st        d      t               j	                  d      j                  t        |j                               j                  d|      j                  d|      j                  dd      j                         }t        j                  |       d	{   }|j                  j                   d
k7  rt        d|j                         |j                  | j                   d<   t        |j                        }|| j                   d
<   |S 7 tw)a3  Calls the merchant agent to find products matching the user's intent.

  Args:
    tool_context: The ADK supplied tool context.
    debug_mode: Whether the agent is in debug mode.

  Returns:
    A list of CartMandate objects.

  Raises:
    RuntimeError: If the merchant agent fails to provide products.
  r   z-No IntentMandate found in tool context state.z)No risk data found in tool context state.z2Find products that match the user's IntentMandate.	risk_datar"   shopping_agent_idtrusted_shopping_agentN	completedzFailed to find products: shopping_context_id
cart_mandates)r   RuntimeError_collect_risk_datar   add_textadd_datar
   
model_dumpbuildr   send_a2a_messagestatus
context_id_parse_cart_mandates	artifacts)r   r"   r   r$   messagetaskr)   s          r   
find_productsr7   H   s      %%&67.	
F
GG .)	
B
CCxDEx')B)B)DExY'xj)x#%=>uw 
 %55g>	>$	[[+%
24;;-@
AA.2oo,*+&t~~6-(5,_%	 
?s   CD?D=	A5D?cart_idc                     |j                   j                  dg       }|D ]W  }t        d|j                  j                   d|         |j                  j                  | k(  sB| |j                   d<   d|  dc S  d|  dS )zUpdates the chosen CartMandate in the tool context state.

  Args:
    cart_id: The ID of the chosen cart.
    tool_context: The ADK supplied tool context.
  r)   zChecking cart with ID: z with chosen ID: chosen_cart_idzCartMandate with ID z
 selected.z not found.)r   getprintcontentsid)r8   r   r)   carts       r   update_chosen_cart_mandater@   q   s     &2%7%7%;%;OR%P-d	
!$--"2"2!33DWIN }}7"-4l)*#G9J
77
   y	44r!   r4   c                 ,    t        | t        t              S )z>Parses a list of artifacts into a list of CartMandate objects.)r
   r   r	   )r4   s    r   r3   r3      s    		+@+	NNr!   c                 (    d}|| j                   d<   |S )z(Creates a risk_data in the tool_context.z5eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...fake_risk_datar$   )r   )r   r$   s     r   r+   r+      s      F)$-,[!	r!   N)F)__doc__r   r   r   	a2a.typesr   google.adk.tools.tool_contextr   ap2.types.mandater   r	   r
   r   common.a2a_message_builderr   common.artifact_utilsr
   "roles.shopping_agent.remote_agentsr   strboollistr    r7   r@   r3   dictr+    r!   r   <module>rO      s        5 3 ) 5 + 8 8 D "% %)  Cy  s)	 
 !  
   H 38&&+/&	+&R5 5; 53 5$ODN OtK7H O
[ T r!   

--- Content of roles/shopping_agent/subagents/shipping_address_collector/tools.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tools used by the shipping address collector subagent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process.
"""

from a2a.types import Artifact
from google.adk.tools.tool_context import ToolContext

from ap2.types.contact_picker import CONTACT_ADDRESS_DATA_KEY
from ap2.types.contact_picker import ContactAddress
from common import artifact_utils
from common.a2a_message_builder import A2aMessageBuilder
from roles.shopping_agent.remote_agents import credentials_provider_client


async def get_shipping_address(
    user_email: str,
    tool_context: ToolContext,
) -> ContactAddress:
  """Gets the user's shipping address from the credentials provider.

  Args:
    user_email: The ID of the user to get the shipping address for.
    tool_context: The ADK supplied tool context.

  Returns:
    The user's shipping address.
  """
  message = (
      A2aMessageBuilder()
      .set_context_id(tool_context.state["shopping_context_id"])
      .add_text("Get the user's shipping address.")
      .add_data("user_email", user_email)
      .build()
  )
  task = await credentials_provider_client.send_a2a_message(message)
  shipping_address = artifact_utils.only(_parse_addresses(task.artifacts))
  return shipping_address


def _parse_addresses(artifacts: list[Artifact]) -> list[ContactAddress]:
  """Parses a list of artifacts into a list of ContactAddress objects."""
  return artifact_utils.find_canonical_objects(
      artifacts, CONTACT_ADDRESS_DATA_KEY, ContactAddress
  )


--- Content of roles/shopping_agent/subagents/shipping_address_collector/__init__.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Shipping Address Collector Agent."""

from . import agent


--- Content of roles/shopping_agent/subagents/shipping_address_collector/agent.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""An agent responsible for collecting the user's shipping address.

The shopping agent delegates responsibility for collecting the user's shipping
address to this subagent, after the user has chosen a product.

In this sample, the shopping agent assumes it must collect the shipping address
before finalizing the cart, as it may impact costs such as shipping and tax.

Also in this sample, the shopping agent offers the user the option of using a
digital wallet to provide their shipping address.

This is just one of many possible approaches.
"""

from . import tools
from common.retrying_llm_agent import RetryingLlmAgent
from common.system_utils import DEBUG_MODE_INSTRUCTIONS

shipping_address_collector = RetryingLlmAgent(
    model="gemini-2.5-flash",
    name="shipping_address_collector",
    max_retries=5,
    instruction="""
        You are an agent responsible for obtaining the user's shipping address.

    %s

        When asked to complete a task, follow these instructions:
        1. Ask the user "Would you prefer to use a digital wallet to access
        your credentials for this purchase, or would you like to enter
        your shipping address manually?"
        2. Proceed depending on the following scenarios:

        Scenario 1:
        The user wants to use their digital wallet (e.g. PayPal or Google Wallet).
        Do not add any additional digital wallet options to the list.
        Instructions:
        1. Collect the info that what is the digital wallet the user would
           like to use for this transaction.
        2. Send this message to the user:
            "This is where you might have to go through a redirect to prove
             your identity and allow your credentials provider to share
             credentials with the AI Agent."
        3. Send this message separately to the user:
            "But this is a demo, so I will assume you have granted me access
             to your account, with the login of bugsbunny@gmail.com.

             Is that ok?"
        4. Collect the user's agreement to access their account.
        5. Once the user agrees, delegate to the 'get_shipping_address' tool
           to collect the user's shipping address. Give bugsbunny@gmail.com
           as the user's email address.
        6. The `get_shipping_address` tool will return the user's shipping
           address. Transfer back to the root_agent with the shipping address.

        Scenario 2:
        Condition: The user wants to enter their shipping address manually.
        Instructions:
        1. Collect the user's shipping address. Ensure you have collected all
           of the necessary parts of a US address.
        2. Transfer back to the root_agent with the shipping address.
    """ % DEBUG_MODE_INSTRUCTIONS,
    tools=[
        tools.get_shipping_address,
    ],
)


--- Content of roles/shopping_agent/subagents/shipping_address_collector/__pycache__/agent.cpython-312.pyc ---



    lhT
                     b    d Z ddlmZ ddlmZ ddlmZ  edddd	ez  ej                  g
      Zy)a  An agent responsible for collecting the user's shipping address.

The shopping agent delegates responsibility for collecting the user's shipping
address to this subagent, after the user has chosen a product.

In this sample, the shopping agent assumes it must collect the shipping address
before finalizing the cart, as it may impact costs such as shipping and tax.

Also in this sample, the shopping agent offers the user the option of using a
digital wallet to provide their shipping address.

This is just one of many possible approaches.
   )tools    )RetryingLlmAgent)DEBUG_MODE_INSTRUCTIONSzgemini-2.5-flashshipping_address_collector   ax  
        You are an agent responsible for obtaining the user's shipping address.

    %s

        When asked to complete a task, follow these instructions:
        1. Ask the user "Would you prefer to use a digital wallet to access
        your credentials for this purchase, or would you like to enter
        your shipping address manually?"
        2. Proceed depending on the following scenarios:

        Scenario 1:
        The user wants to use their digital wallet (e.g. PayPal or Google Wallet).
        Do not add any additional digital wallet options to the list.
        Instructions:
        1. Collect the info that what is the digital wallet the user would
           like to use for this transaction.
        2. Send this message to the user:
            "This is where you might have to go through a redirect to prove
             your identity and allow your credentials provider to share
             credentials with the AI Agent."
        3. Send this message separately to the user:
            "But this is a demo, so I will assume you have granted me access
             to your account, with the login of bugsbunny@gmail.com.

             Is that ok?"
        4. Collect the user's agreement to access their account.
        5. Once the user agrees, delegate to the 'get_shipping_address' tool
           to collect the user's shipping address. Give bugsbunny@gmail.com
           as the user's email address.
        6. The `get_shipping_address` tool will return the user's shipping
           address. Transfer back to the root_agent with the shipping address.

        Scenario 2:
        Condition: The user wants to enter their shipping address manually.
        Instructions:
        1. Collect the user's shipping address. Ensure you have collected all
           of the necessary parts of a US address.
        2. Transfer back to the root_agent with the shipping address.
    )modelnamemax_retriesinstructionr   N)	__doc__ r   common.retrying_llm_agentr   common.system_utilsr   get_shipping_addressr        s/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent/subagents/shipping_address_collector/agent.py<module>r      sL     6 7-
	%'N "O'"R 	""Y/ r   

--- Content of roles/shopping_agent/subagents/shipping_address_collector/__pycache__/__init__.cpython-312.pyc ---



    lh}                         d Z ddlmZ y)z!Shipping Address Collector Agent.   )agentN)__doc__ r        v/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent/subagents/shipping_address_collector/__init__.py<module>r	      s
    ( r   

--- Content of roles/shopping_agent/subagents/shipping_address_collector/__pycache__/tools.cpython-312.pyc ---



    lh@                         d Z ddlmZ ddlmZ ddlmZ ddlmZ ddlm	Z	 ddl
mZ ddlm
Z
 d	ed
edefdZd
ee   dee   fdZy)zTools used by the shipping address collector subagent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process.
    )Artifact)ToolContext)CONTACT_ADDRESS_DATA_KEY)ContactAddress)artifact_utils)A2aMessageBuilder)credentials_provider_client
user_emailtool_contextreturnc                 B  K   t               j                  |j                  d         j                  d      j	                  d|       j                         }t
        j                  |       d{   }t        j                  t        |j                              }|S 7 .w)zGets the user's shipping address from the credentials provider.

  Args:
    user_email: The ID of the user to get the shipping address for.
    tool_context: The ADK supplied tool context.

  Returns:
    The user's shipping address.
  shopping_context_idz Get the user's shipping address.r
   N)r   set_context_idstateadd_textadd_databuildr	   send_a2a_messager   only_parse_addresses	artifacts)r
   r   messagetaskshipping_addresss        s/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent/subagents/shipping_address_collector/tools.pyget_shipping_addressr      s      ~l(()>?@x23xj)uw 
 +;;GD	D$#(()9$..)IJ	 
Es   A,B.B//Br   c                 @    t        j                  | t        t              S )zAParses a list of artifacts into a list of ContactAddress objects.)r   find_canonical_objectsr   r   )r   s    r   r   r   8   s    		.	.)>
     N)__doc__	a2a.typesr   google.adk.tools.tool_contextr   ap2.types.contact_pickerr   r   commonr   common.a2a_message_builderr   "roles.shopping_agent.remote_agentsr	   strr   listr    r   r   <module>r*      s\     5 = 3 ! 8 J 2X 43G r   

--- Content of roles/shopping_agent/subagents/payment_method_collector/tools.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tools used by the payment method collector subagent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process.
"""

from google.adk.tools.tool_context import ToolContext

from ap2.types.payment_request import PAYMENT_METHOD_DATA_DATA_KEY
from common.a2a_message_builder import A2aMessageBuilder
from common import artifact_utils
from roles.shopping_agent.remote_agents import credentials_provider_client


async def get_payment_methods(
    user_email: str,
    tool_context: ToolContext,
) -> list[str]:
  """Gets the user's payment methods from the credentials provider.

  These will match the payment method on the cart being purchased.

  Args:
    user_email: Identifies the user's account
    tool_context: The ADK supplied tool context.

  Returns:
    A dictionary of the user's applicable payment methods.
  """
  cart_mandate = tool_context.state["cart_mandate"]
  message_builder = (
      A2aMessageBuilder()
      .set_context_id(tool_context.state["shopping_context_id"])
      .add_text("Get a filtered list of the user's payment methods.")
      .add_data("user_email", user_email)
  )
  for method_data in cart_mandate.contents.payment_request.method_data:
    message_builder.add_data(
        PAYMENT_METHOD_DATA_DATA_KEY,
        method_data.model_dump(),
    )
  task = await credentials_provider_client.send_a2a_message(
      message_builder.build()
  )
  payment_methods = artifact_utils.get_first_data_part(task.artifacts)
  return payment_methods


async def get_payment_credential_token(
    user_email: str,
    payment_method_alias: str,
    tool_context: ToolContext,
) -> str:
  """Gets a payment credential token from the credentials provider.

  Args:
    user_email: The user's email address.
    payment_method_alias: The payment method alias.
    tool_context: The ADK supplied tool context.

  Returns:
    Status of the call and the payment credential token.
  """
  message = (
      A2aMessageBuilder()
      .set_context_id(tool_context.state["shopping_context_id"])
      .add_text("Get a payment credential token for the user's payment method.")
      .add_data("payment_method_alias", payment_method_alias)
      .add_data("user_email", user_email)
      .build()
  )
  task = await credentials_provider_client.send_a2a_message(message)
  data = artifact_utils.get_first_data_part(task.artifacts)
  token = data.get("token")
  credentials_provider_agent_card = (
      await credentials_provider_client.get_agent_card()
  )

  tool_context.state["payment_credential_token"] = {
      "value": token,
      "url": credentials_provider_agent_card.url,
  }
  return {"status": "success", "token": token}


--- Content of roles/shopping_agent/subagents/payment_method_collector/__init__.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Payment Method Collector Agent."""

from . import agent


--- Content of roles/shopping_agent/subagents/payment_method_collector/agent.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""An agent responsible for collecting the user's choice of payment method.

The shopping agent delegates responsibility for collecting the user's choice of
payment method to this subagent, after the user has finalized their cart.

Through the get_payment_methods tool, the agent retrieves a list of eligible
payment methods from the credentials provider agent. The agent then presents the
list to the user, allowing them to select their preferred payment method.

After selection, the agent gets a purchase token from the credentials
provider, which is then sent to the merchant agent for payment.
"""

from . import tools
from common.retrying_llm_agent import RetryingLlmAgent
from common.system_utils import DEBUG_MODE_INSTRUCTIONS


payment_method_collector = RetryingLlmAgent(
    model="gemini-2.5-flash",
    name="payment_method_collector",
    max_retries=5,
    instruction="""
    You are an agent responsible for obtaining the user's payment method for a
    purchase.

    %s

    When asked to complete a task, follow these instructions:
    1. Ensure a CartMandate object was provided to you.
    2. Present a clear and organized summary of the cart to the user. The
       summary should be divided into two main sections:
       a. Order Summary:
          Merchant: The name of the merchant.
          Item: Display the item_name clearly.
          Price Breakdown:
            Shipping: The shipping cost from the `shippingOptions`.
            Tax: The tax amount, if available.
            Total: The final total price from the `total` field in the
              `payment_request`.
            Format all amounts with commas and the currency symbol.
          Expires: Convert the cart_expiry into a human-readable format
            (e.g., "in 2 hours," "by tomorrow at 5 PM"). Convert the time to the
            user's timezone.
          Refund Period: Convert the refund_period into a human-readable format
            (e.g., "30 days," "14 days").
       b. Show the full shipping address collected earlier in a well-formatted
          manner.
       Ensure the entire presentation is well-formatted and easy to read.
    3. Call the `get_payment_methods` tool to get eligible
       payment_method_aliases with the method_data from the CartMandate's
       payment_request. Present the payment_method_aliases to the user in
       a numbered list.
    4. Ask the user to choose which of their forms of payment they would
       like to use for the payment. Remember that payment_method_alias.
    5. Call the `get_payment_credential_token` tool to get the payment
       credential token with the user_email and payment_method_alias.
    6. Transfer back to the root_agent with the payment_method_alias.
    """ % DEBUG_MODE_INSTRUCTIONS,
    tools=[
        tools.get_payment_methods,
        tools.get_payment_credential_token,
    ],
)


--- Content of roles/shopping_agent/subagents/payment_method_collector/__pycache__/agent.cpython-312.pyc ---



    lht
                     x    d Z ddlmZ ddlmZ ddlmZ  edddd	ez  ej                  ej                  g
      Z	y)aT  An agent responsible for collecting the user's choice of payment method.

The shopping agent delegates responsibility for collecting the user's choice of
payment method to this subagent, after the user has finalized their cart.

Through the get_payment_methods tool, the agent retrieves a list of eligible
payment methods from the credentials provider agent. The agent then presents the
list to the user, allowing them to select their preferred payment method.

After selection, the agent gets a purchase token from the credentials
provider, which is then sent to the merchant agent for payment.
   )tools    )RetryingLlmAgent)DEBUG_MODE_INSTRUCTIONSzgemini-2.5-flashpayment_method_collector   a:  
    You are an agent responsible for obtaining the user's payment method for a
    purchase.

    %s

    When asked to complete a task, follow these instructions:
    1. Ensure a CartMandate object was provided to you.
    2. Present a clear and organized summary of the cart to the user. The
       summary should be divided into two main sections:
       a. Order Summary:
          Merchant: The name of the merchant.
          Item: Display the item_name clearly.
          Price Breakdown:
            Shipping: The shipping cost from the `shippingOptions`.
            Tax: The tax amount, if available.
            Total: The final total price from the `total` field in the
              `payment_request`.
            Format all amounts with commas and the currency symbol.
          Expires: Convert the cart_expiry into a human-readable format
            (e.g., "in 2 hours," "by tomorrow at 5 PM"). Convert the time to the
            user's timezone.
          Refund Period: Convert the refund_period into a human-readable format
            (e.g., "30 days," "14 days").
       b. Show the full shipping address collected earlier in a well-formatted
          manner.
       Ensure the entire presentation is well-formatted and easy to read.
    3. Call the `get_payment_methods` tool to get eligible
       payment_method_aliases with the method_data from the CartMandate's
       payment_request. Present the payment_method_aliases to the user in
       a numbered list.
    4. Ask the user to choose which of their forms of payment they would
       like to use for the payment. Remember that payment_method_alias.
    5. Call the `get_payment_credential_token` tool to get the payment
       credential token with the user_email and payment_method_alias.
    6. Transfer back to the root_agent with the payment_method_alias.
    )modelnamemax_retriesinstructionr   N)
__doc__ r   common.retrying_llm_agentr   common.system_utilsr   get_payment_methodsget_payment_credential_tokenr        q/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent/subagents/payment_method_collector/agent.py<module>r      sW     6 7 ,
	#$H "I$"L 	!!
**S- r   

--- Content of roles/shopping_agent/subagents/payment_method_collector/__pycache__/__init__.cpython-312.pyc ---



    lh{                         d Z ddlmZ y)zPayment Method Collector Agent.   )agentN)__doc__ r        t/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent/subagents/payment_method_collector/__init__.py<module>r	      s
    & r   

--- Content of roles/shopping_agent/subagents/payment_method_collector/__pycache__/tools.cpython-312.pyc ---



    lh                     v    d Z ddlmZ ddlmZ ddlmZ ddlmZ ddl	m
Z
 deded	ee   fd
Z
dededed	efdZy
)zTools used by the payment method collector subagent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process.
    )ToolContext)PAYMENT_METHOD_DATA_DATA_KEY)A2aMessageBuilder)artifact_utils)credentials_provider_client
user_emailtool_contextreturnc                   K   |j                   d   }t               j                  |j                   d         j                  d      j	                  d|       }|j
                  j                  j                  D ]&  }|j	                  t        |j                                ( t        j                  |j                                d{   }t        j                  |j                        }|S 7 %w)a4  Gets the user's payment methods from the credentials provider.

  These will match the payment method on the cart being purchased.

  Args:
    user_email: Identifies the user's account
    tool_context: The ADK supplied tool context.

  Returns:
    A dictionary of the user's applicable payment methods.
  cart_mandateshopping_context_idz2Get a filtered list of the user's payment methods.r   N)stater   set_context_idadd_textadd_datacontentspayment_requestmethod_datar   
model_dumpr   send_a2a_messagebuildr   get_first_data_part	artifacts)r   r	   r   message_builderr   taskpayment_methodss          q/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent/subagents/payment_method_collector/tools.pyget_payment_methodsr      s      ##N3,~l(()>?@xDExj)	  "**::FFk$  G
 +;; 
$ #66t~~F/		
s   CC.C,&C.payment_method_aliasc                   K   t               j                  |j                  d         j                  d      j	                  d|      j	                  d|       j                         }t
        j                  |       d{   }t        j                  |j                        }|j                  d      }t
        j                          d{   }||j                  d|j                  d<   d	|d
S 7 q7 'w)a  Gets a payment credential token from the credentials provider.

  Args:
    user_email: The user's email address.
    payment_method_alias: The payment method alias.
    tool_context: The ADK supplied tool context.

  Returns:
    Status of the call and the payment credential token.
  r
   z=Get a payment credential token for the user's payment method.r   r   Ntoken)valueurlpayment_credential_tokensuccess)statusr!   )r   r   r   r   r   r   r   r   r   r   r   getget_agent_cardr#   )r   r   r	   messager   datar!   credentials_provider_agent_cards           r   get_payment_credential_tokenr,   ?   s       ~l(()>?@xOPx&(<=xj)uw
 
 +;;GD	D$		+	+DNN	;$
((7
%'6688 "
 
,
0
04,/0 	.. 
E 9s%   A<C4>C0?AC4
C2&C42C4N)__doc__google.adk.tools.tool_contextr   ap2.types.payment_requestr   common.a2a_message_builderr   commonr   "roles.shopping_agent.remote_agentsr   strlistr   r,        r   <module>r7      sh    6 B 8 ! J 
#YD"/"/"/ "/ 		"/r6   

--- Content of roles/shopping_agent/__pycache__/remote_agents.cpython-312.pyc ---



    lh}                     P    d Z ddlmZ ddlmZ  eddeh      Z eddeh      Zy	)
a*  Clients used by the shopping agent to communicate with remote agents.

Clients request activation of the Agent Payments Protocol extension by including
the X-A2A-Extensions header in each HTTP request.

This registry serves as the initial allowlist of remote agents that the shopping
agent trusts.
    )
EXTENSION_URI)PaymentRemoteA2aClientcredentials_providerz.http://localhost:8002/a2a/credentials_provider)namebase_urlrequired_extensionsmerchant_agentz(http://localhost:8001/a2a/merchant_agentN)__doc__common.a2a_extension_utilsr    common.payment_remote_a2a_clientr   credentials_provider_clientmerchant_agent_client     V/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent/remote_agents.py<module>r      sH    5 C 5	
=  /	
7 r   

--- Content of roles/shopping_agent/__pycache__/agent.cpython-312.pyc ---



    lh                         d Z ddlmZ ddlmZ ddlmZ ddlmZ ddl	m
Z
 ddlmZ  e
d	d
ddez  ej                  ej                  ej                  ej                   ej"                  ej$                  geeeg
      Zy)aF  A shopping agent.

The shopping agent's role is to engage with a user to:
1. Find products offered by merchants that fulfills the user's shopping intent.
2. Help complete the purchase of their chosen items.

The Google ADK powers this shopping agent, chosen for its simplicity and
efficiency in developing robust LLM agents. 
   )tools)payment_method_collector)shipping_address_collector)shopper    )RetryingLlmAgent)DEBUG_MODE_INSTRUCTIONS   zgemini-2.5-flash
root_agenta  
          You are a shopping agent responsible for helping users find and
          purchase products from merchants.

          Follow these instructions, depending upon the scenario:

    %s

          Follow these instructions, depending upon the scenario:

          Scenario 1:
          The user asks to buy or shop for something.
          1. Delegate to the `shopper` agent to collect the products the user
             is interested in purchasing. The `shopper` agent will return a
             message indicating if the chosen cart mandate is ready or not.
          2. Once a success message is received, delegate to the
            `shipping_address_collector` agent to collect the user's shipping
            address.
          3. The shipping_address_collector agent will return the user's
             shipping address. Display the shipping address to the user.
          4. Once you have the shipping address, call the `update_cart` tool to
             update the cart. You will receive a new, signed `CartMandate`
             object.
          5. Delegate to the `payment_method_collector` agent to collect the
             user's payment method.
          6. The `payment_method_collector` agent will return the user's
             payment method alias.
          7. Send this message separately to the user:
               'This is where you would be redirected to a trusted surface to
               confirm the purchase.'
               'But this is a demo, so you can confirm your purchase here.'
          8. Call the `create_payment_mandate` tool to create a payment mandate.
          9. Present to the user the final cart contents including price,
               shipping, tax, total price, how long the cart is valid for (in a
               human-readable format) and how long it can be refunded (in a
               human-readable format). In a second block, show the shipping
               address. Format it all nicely. In a third block, show the user's
               payment method alias. Format it nicely.
          10. Confirm with the user they want to purchase the selected item
              using the selected form of payment.
          11. When the user confirms purchase call the following tools in order:
             a. `sign_mandates_on_user_device`
             b. `send_signed_payment_mandate_to_credentials_provider`
          12. Initiate the payment by calling the `initiate_payment` tool.
          13. If prompted for an OTP, relay the OTP request to the user.
              Do not ask the user for anything other than the OTP request.
              Once you have an challenge response, display the display_text
              from it and then call the `initiate_payment_with_otp`
              tool to retry the payment. Surface the result to the user.
          14. If the response is a success or confirmation, create a block of
              text titled 'Payment Receipt'. Ensure its contents includes
              price, shipping, tax and total price. In a second block, show the
              shipping address. Format it all nicely. In a third block, show the
              user's payment method alias. Format it nicely and give it to the
              user.

         Scenario 2:
         The user first wants you to describe all the data passed between you,
         tools, and other agents before starting with their shopping prompt.
         1. Listen to the user's request for describing the process you are
            following and the data passed between you, tools, and other agents.
            Describe the process you are following. Share data and tools used.
            Anytime you reach out to other agents, ask them to describe the data
            they are receiving and sending as well as the tools they are using.
            Be sure to include which agent is currently speaking to the user.
         2. Follow the instructions for Scenario 1 once the user confirms they
            want to start with their shopping prompt.

         Scenario 3:
         The users ask you do to anything else.
          1. Respond to the user with this message:
             "Hi, I'm your shopping assistant. How can I help you?  For example,
             you can say 'I want to buy a pair of shoes'"
          )max_retriesmodelnameinstructionr   
sub_agentsN)__doc__ r   (subagents.payment_method_collector.agentr   *subagents.shipping_address_collector.agentr   subagents.shopper.agentr   common.retrying_llm_agentr   common.system_utilsr	   create_payment_mandateinitiate_paymentinitiate_payment_with_otp3send_signed_payment_mandate_to_credentials_providersign_mandates_on_user_deviceupdate_cartr        N/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent/agent.py<module>r!      s     N R , 6 7 
	IR (SI(V 	$$

''
AA
**

 	" m[
r   

--- Content of roles/shopping_agent/__pycache__/__init__.cpython-312.pyc ---



    lhv                         d Z ddlmZ y)zThe shopping agent module.   )agentN)__doc__ r        Q/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent/__init__.py<module>r	      s
    ! r   

--- Content of roles/shopping_agent/__pycache__/tools.cpython-312.pyc ---



    lh7+              	          d Z ddlmZ ddlmZ ddlZddlmZ ddlmZ ddlm	Z	 dd	lm
Z
 dd
lmZ ddl
mZ ddl
mZ dd
l
mZ ddl
mZ ddl
mZ ddlmZ ddlmZ ddlmZ 	 d&dedededefdZd&dedefdZ	 d&dededefdZdedededefdZdedefdZ	 d&dededefdZ d edefd!Z!d"edefd#Z"d$e#e   de#e   fd%Z$y)'zTools used by the Shopping Agent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process, such as updating a cart or initiating payment.
    )datetime)timezoneN)Artifact)ToolContext   )credentials_provider_client)merchant_agent_client)ContactAddress)CART_MANDATE_DATA_KEY)CartMandate)PAYMENT_MANDATE_DATA_KEY)PaymentMandate)PaymentMandateContents)PaymentResponse)artifact_utils)A2aMessageBuildershipping_addresstool_context
debug_modereturnc                   K   |j                   d   }|st        d      t               j                  |j                   d         j	                  d      j                  d|      j                  d|       j                  dd      j                  d	|      j
                         }t        j                  |       d
{   }t        j                  t        |j                              }||j                   d<   | |j                   d<   |S 7 Lw)a  Notifies the merchant agent of a shipping address selection for a cart.

  Args:
    shipping_address: The user's selected shipping address.
    tool_context: The ADK supplied tool context.
    debug_mode: Whether the agent is in debug mode.

  Returns:
    The updated CartMandate.
  chosen_cart_idz3No chosen cart mandate found in tool context state.shopping_context_idz1Update the cart with the user's shipping address.cart_idr   shopping_agent_idtrusted_shopping_agentr   Ncart_mandate)
stateRuntimeErrorr   set_context_idadd_textadd_databuildr	   send_a2a_messager   only_parse_cart_mandates	artifacts)r   r   r   r   messagetaskupdated_cart_mandates          N/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent/tools.pyupdate_cartr,   )   s       %%&67.	
L
MM ~l(()>?@xCDx	>*x"$45x#%=>xj)uw 
 %55g>	>$',,4>>* (<,^$+;,'(	 
?s   B8D	:D;A
D	c                   K   | j                   d   }|st        d      | j                   d   }|st        d      t               j                  | j                   d         j	                  d      j                  t        |      j                  d|      j                  dd      j                  d	|      j                         }t        j                  |       d
{   }|j                  | j                   d<   |j                  S 7 )w)zInitiates a payment using the payment mandate from state.

  Args:
    tool_context: The ADK supplied tool context.
    debug_mode: Whether the agent is in debug mode.

  Returns:
    The status of the payment initiation.
  signed_payment_mandate6No signed payment mandate found in tool context state.	risk_data)No risk data found in tool context state.r   zInitiate a paymentr   r   r   Ninitiate_payment_task_id)r   r   r   r    r!   r"   r
   r#   r	   r$   idstatus)r   r   payment_mandater0   outgoing_message_builderr)   s         r+   initiate_paymentr7   R   s      !&&'?@/	
O
PP  -)	
B
CC ~l(()>?@x$%x(/:xY'x#%=>xj)uw  %556NO	O$3777,/0	
 
Ps   CDD*Dchallenge_responsec                 6  K   |j                   d   }|st        d      |j                   d   }|st        d      t               j                  |j                   d         j	                  |j                   d         j                  d      j
                  t        |      j
                  dd	      j
                  d
|       j
                  d|      j
                  d|      j                         }t        j                  |       d{   }|j                  S 7 w)
a  Initiates a payment using the payment mandate from state and a

    challenge response. In our sample, the challenge response is a one-time
    password (OTP) sent to the user.

  Args:
    challenge_response: The challenge response.
    tool_context: The ADK supplied tool context.
    debug_mode: Whether the agent is in debug mode.

  Returns:
    The status of the payment initiation.
  r.   r/   r0   r1   r   r2   z3Initiate a payment. Include the challenge response.r   r   r8   r   N)r   r   r   r    set_task_idr!   r"   r
   r#   r	   r$   r4   )r8   r   r   r5   r0   r6   r)   s          r+   initiate_payment_with_otpr;   r   s       !&&'?@/	
O
PP  -)	
B
CC ~l(()>?@{<%%&@ABxEFx(/:x#%=>x$&89xY'xj)uw  %556NO	O$	
 
Ps   DDDDpayment_method_alias
user_emailc           
      6   |j                   d   }|j                  j                  }|j                   d   }t        |j                  j
                  dd|j                   d   i||      }t
        t        t        j                         j                  t        j                  t        j                        j                         |j                  j
                  |j                  j                   ||j                  j"                              }||j                   d	<   |S )
zCreates a payment mandate and stores it in state.

  Args:
    payment_method_alias: The payment method alias.
    user_email: The user's email address.
    tool_context: The ADK supplied tool context.

  Returns:
    The payment mandate.
  r   r   CARDtokenpayment_credential_token)
request_idmethod_namedetailsr   payer_email)payment_mandate_id	timestamppayment_details_idpayment_details_totalpayment_responsemerchant_agentpayment_mandate_contentsr5   )r   contentspayment_requestr   rD   r3   r   r   uuiduuid4hexr   nowr   utc	isoformattotal
merchant_name)r<   r=   r   r   rO   r   rJ   r5   s           r+   create_payment_mandaterX      s     ##N3, ))99/!''(:;$ ((++
<%%&@A ( #5!ZZ\--LL.88:,4477 / 7 7 = =+%..<<
 	/ +:,&'	    c                     | j                   d   }| j                   d   }t        |      }t        |j                        }|dz   |z   |_        || j                   d<   |j                  S )a  Simulates signing the transaction details on a user's secure device.

  This function represents the step where the final transaction details,
  including hashes of the cart and payment mandates, would be sent to a
  secure hardware element on the user's device (e.g., Secure Enclave) to be
  cryptographically signed with the user's private key.

  Note: This is a placeholder implementation. It does not perform any actual
  cryptographic operations. It simulates the creation of a signature by
  concatenating the mandate hashes.

  Args:
      tool_context: The context object used for state management. It is expected
        to contain the `payment_mandate` and `cart_mandate`.

  Returns:
      A string representing the simulated user authorization signature (JWT).
  r5   r   _r.   )r   _generate_cart_mandate_hash_generate_payment_mandate_hashrM   user_authorization)r   r5   r   cart_mandate_hashpayment_mandate_hashs        r+   sign_mandates_on_user_devicera      s|    & %1$6$67H$I/*00@,1,?7.. # 44 $ 2A,-.		+	++rY   c                   K   | j                   d   }|st        d      | j                   d   }|st        d      t               j                  | j                   d         j	                  d      j                  t        |      j                  d|      j                  d|      j                         }t        j                  |       d{   S 7 w)	zSends the signed payment mandate to the credentials provider.

  Args:
    tool_context: The ADK supplied tool context.
    debug_mode: Whether the agent is in debug mode.
  r.   r/   r0   r1   r   z"This is the signed payment mandater   N)
r   r   r   r    r!   r"   r
   r#   r   r$   )r   r   r5   r0   r(   s        r+   3send_signed_payment_mandate_to_credentials_providerrc      s      !&&'?@/	
O
PP  -)	
B
CC~l(()>?@x45x(/:xY'xj)uw 
 +;;GD	DD	Ds   CC
CCr   c                 4    d| j                   j                  z   S )a*  Generates a cryptographic hash of the CartMandate.

  This hash serves as a tamper-proof reference to the specific merchant-signed
  cart offer that the user has approved.

  Note: This is a placeholder implementation for development. A real
  implementation must use a secure hashing algorithm (e.g., SHA-256) on the
  canonical representation of the CartMandate object.

  Args:
      cart_mandate: The complete CartMandate object, including the merchant's
        authorization.

  Returns:
      A string representing the hash of the cart mandate.
  fake_cart_mandate_hash_)rN   r3   )r   s    r+   r\   r\     s    " 
#\%:%:%=%=	==rY   rM   c                      d| j                   z   S )a$  Generates a cryptographic hash of the PaymentMandateContents.

  This hash creates a tamper-proof reference to the specific payment details
  the user is about to authorize.

  Note: This is a placeholder implementation for development. A real
  implementation must use a secure hashing algorithm (e.g., SHA-256) on the
  canonical representation of the PaymentMandateContents object.

  Args:
      payment_mandate_contents: The payment mandate contents to hash.

  Returns:
      A string representing the hash of the payment mandate contents.
  fake_payment_mandate_hash_)rF   rL   s    r+   r]   r]     s    & #%=%P%PPrY   r'   c                 @    t        j                  | t        t              S )z>Parses a list of artifacts into a list of CartMandate objects.)r   find_canonical_objectsr   r   )r'   s    r+   r&   r&   0  s    		.	.&
 rY   )F)%__doc__r   r   rP   	a2a.typesr   google.adk.tools.tool_contextr   
remote_agentsr   r	   ap2.types.contact_pickerr
   ap2.types.mandater   r   r
   r   r   ap2.types.payment_requestr   commonr   common.a2a_message_builderr   boolstrr,   r7   r;   rX   ra   rc   r\   r]   listr&    rY   r+   <module>rw      sN       5 6 0 3 3 ) 6 , 4 5 ! 8 &$&& & 		&R $ B LQ%%+6%DH%P))) ) 		)X ,{  ,s  ,J EEE 	E8>k >c >(4.DN tK7H rY   

--- Content of roles/merchant_agent/tools.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tools used by the merchant agent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process.
"""

import base64
import json
import logging

from pydantic import ValidationError
from typing import Any

from a2a.server.tasks.task_updater import TaskUpdater
from a2a.types import DataPart
from a2a.types import Part
from a2a.types import Task
from a2a.types import TextPart

from . import storage
from ap2.types.contact_picker import ContactAddress
from ap2.types.mandate import CART_MANDATE_DATA_KEY
from ap2.types.mandate import PAYMENT_MANDATE_DATA_KEY
from ap2.types.mandate import PaymentMandate
from ap2.types.payment_request import PaymentCurrencyAmount
from ap2.types.payment_request import PaymentItem
from common import message_utils
from common.a2a_extension_utils import EXTENSION_URI
from common.a2a_message_builder import A2aMessageBuilder
from common.payment_remote_a2a_client import PaymentRemoteA2aClient

# A map of payment method types to their corresponding processor agent URLs.
# This is the set of linked Merchant Payment Processor Agents this Merchant
# is integrated with.
_PAYMENT_PROCESSORS_BY_PAYMENT_METHOD_TYPE = {
    "CARD": "http://localhost:8003/a2a/merchant_payment_processor_agent",
}

# A placeholder for a JSON Web Token (JWT) used for merchant authorization.
_FAKE_JWT = "eyJhbGciOiJSUzI1NiIsImtpZIwMjQwOTA..."


async def update_cart(
    data_parts: list[dict[str, Any]],
    updater: TaskUpdater,
    current_task: Task | None,
    debug_mode: bool = False,
) -> None:
  """Updates an existing cart after a shipping address is provided.

  Args:
    data_parts: A list of data part contents from the request.
    updater: The TaskUpdater instance to add artifacts and complete the task.
    current_task: The current task -- not used in this function.
    debug_mode: Whether the agent is in debug mode.
  """
  cart_id = message_utils.find_data_part("cart_id", data_parts)
  if not cart_id:
    await _fail_task(updater, "Missing cart_id.")
    return

  shipping_address = message_utils.find_data_part(
      "shipping_address", data_parts
  )
  if not shipping_address:
    await _fail_task(updater, "Missing shipping_address.")
    return

  cart_mandate = storage.get_cart_mandate(cart_id)
  if not cart_mandate:
    await _fail_task(updater, f"CartMandate not found for cart_id: {cart_id}")
    return

  risk_data = storage.get_risk_data(updater.context_id)
  if not risk_data:
    await _fail_task(
        updater, f"Missing risk_data for context_id: {updater.context_id}"
    )
    return

  # Update the CartMandate with new shipping and tax cost.
  try:
    # Add the shipping address to the CartMandate:
    cart_mandate.contents.payment_request.shipping_address = (
        ContactAddress.model_validate(shipping_address)
    )

    # Add new shipping and tax costs to the PaymentRequest:
    tax_and_shipping_costs = [
        PaymentItem(
            label="Shipping",
            amount=PaymentCurrencyAmount(currency="USD", value=2.00),
        ),
        PaymentItem(
            label="Tax",
            amount=PaymentCurrencyAmount(currency="USD", value=1.50),
        ),
    ]

    payment_request = cart_mandate.contents.payment_request

    if payment_request.details.display_items is None:
      payment_request.details.display_items = tax_and_shipping_costs
    else:
      payment_request.details.display_items.extend(tax_and_shipping_costs)

    # Recompute the total amount of the PaymentRequest:
    payment_request.details.total.amount.value = sum(
        item.amount.value for item in payment_request.details.display_items
    )

    # A base64url-encoded JSON Web Token (JWT) that digitally signs the cart
    # contents by the merchant's private key.
    cart_mandate.merchant_authorization = _FAKE_JWT

    await updater.add_artifact([
        Part(
            root=DataPart(
                data={CART_MANDATE_DATA_KEY: cart_mandate.model_dump()}
            )
        ),
        Part(root=DataPart(data={"risk_data": risk_data})),
    ])
    await updater.complete()

  except ValidationError as e:
    await _fail_task(updater, f"Invalid CartMandate after update: {e}")


async def initiate_payment(
    data_parts: list[dict[str, Any]],
    updater: TaskUpdater,
    current_task: Task | None,
    debug_mode: bool = False,
) -> None:
  """Initiates a payment for a given payment mandate. Use to make a payment.

  Args:
    data_parts: The data parts from the request, expected to contain a
      PaymentMandate and optionally an challenge response.
    updater: The TaskUpdater instance for updating the task state.
    current_task: The current task, used to find the processor's task ID.
    debug_mode: Whether the agent is in debug mode.
  """
  payment_mandate = message_utils.parse_canonical_object(
      PAYMENT_MANDATE_DATA_KEY, data_parts, PaymentMandate
  )
  if not payment_mandate:
    await _fail_task(updater, "Missing payment_mandate.")
    return

  risk_data = message_utils.find_data_part("risk_data", data_parts)
  if not risk_data:
    await _fail_task(updater, "Missing risk_data.")
    return

  payment_method_type = (
      payment_mandate.payment_mandate_contents.payment_response.method_name
  )
  processor_url = _PAYMENT_PROCESSORS_BY_PAYMENT_METHOD_TYPE.get(
      payment_method_type
  )

  if not processor_url:
    await _fail_task(
        updater, f"No payment processor found for method: {payment_method_type}"
    )
    return

  payment_processor_agent = PaymentRemoteA2aClient(
      name="payment_processor_agent",
      base_url=processor_url,
      required_extensions={
          EXTENSION_URI,
      },
  )

  message_builder = (
      A2aMessageBuilder()
      .set_context_id(updater.context_id)
      .add_text("initiate_payment")
      .add_data(PAYMENT_MANDATE_DATA_KEY, payment_mandate.model_dump())
      .add_data("risk_data", risk_data)
      .add_data("debug_mode", debug_mode)
  )

  challenge_response = (
      message_utils.find_data_part("challenge_response", data_parts) or ""
  )
  if challenge_response:
    message_builder.add_data("challenge_response", challenge_response)

  payment_processor_task_id = _get_payment_processor_task_id(current_task)
  if payment_processor_task_id:
    message_builder.set_task_id(payment_processor_task_id)

  task = await payment_processor_agent.send_a2a_message(message_builder.build())
  await updater.update_status(
      state=task.status.state,
      message=task.status.message,
  )


async def dpc_finish(
    data_parts: list[dict[str, Any]],
    updater: TaskUpdater,
    current_task: Task | None,
) -> None:
  """Receives and validates a DPC response to finalize payment.

  This tool receives the Digital Payment Credential (DPC) response, in the form
  of an OpenID4VP JSON, validates it, and simulates payment finalization.

  Args:
    data_parts: A list of data part contents from the request.
    updater: The TaskUpdater instance to add artifacts and complete the task.
    current_task: The current task, not used in this function.
  """
  dpc_response = message_utils.find_data_part("dpc_response", data_parts)
  if not dpc_response:
    await _fail_task(updater, "Missing dpc_response.")
    return

  logging.info("Received DPC response for finalization: %s", dpc_response)

  # --- Sample validation and payment finalization logic ---
  # TODO: Validate the nonce, and other merchant-specific attributes from the
  # DPC response.
  # TODO: Pass the DPC response to the payment processor agent for validation.

  # Simulate payment finalization.
  await updater.add_artifact([
      Part(root=DataPart(data={
          "payment_status": "SUCCESS",
          "transaction_id": "txn_1234567890",
      }))
  ])
  await updater.complete()


def _get_payment_processor_task_id(task: Task | None) -> str | None:
  """Returns the task ID of the payment processor task, if it exists.

  Identified by assuming the first message with a task ID that is not the
  merchant's task ID is a payment processor message.
  """
  if task is None:
    return None
  for message in task.history:
    if message.task_id != task.id:
      return message.task_id
  return None


async def _fail_task(updater: TaskUpdater, error_text: str) -> None:
  """A helper function to fail a task with a given error message."""
  error_message = updater.new_agent_message(
      parts=[Part(root=TextPart(text=error_text))]
  )
  await updater.failed(message=error_message)


--- Content of roles/merchant_agent/agent.json ---

{
  "name": "MerchantAgent",
  "description": "A sales assistant agent for a merchant.",
  "url": "http://localhost:8001/a2a/merchant_agent",
  "preferredTransport": "JSONRPC",
  "protocolVersion": "0.3.0",
  "version": "1.0.0",
  "defaultInputModes": ["json"],
  "defaultOutputModes": ["json"],
  "capabilities": {
      "extensions": [
        {
          "uri": "https://github.com/google-agentic-commerce/ap2/v1",
          "description": "Supports the Agent Payments Protocol.",
          "required": true
        },
        {
          "uri": "https://sample-card-network.github.io/paymentmethod/types/v1",
          "description": "Supports the Sample Card Network payment method extension",
          "required": true
        }
      ]
  },
    "skills": [
    {
      "id": "search_catalog",
      "name": "Search Catalog",
      "description": "Searches the merchant's catalog based on a shopping intent & returns a cart containing the top results.",
      "parameters": {
        "type": "object",
        "properties": {
          "shopping_intent": {
            "type": "string",
            "description": "A JSON string representing the user's shopping intent."
          }
        },
        "required": ["shopping_intent"]
      },
      "tags": ["merchant", "search", "catalog"]
    }
  ]
}


--- Content of roles/merchant_agent/agent_executor.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A merchant agent executor for handling user shopping requests.

This agent's role is to:
1. Route user intent to a catalog for product discovery.
2. Handle requests to update a shopping cart.
3. Forward payment requests to the appropriate payment processor.

In order to clearly demonstrate the use of the Agent Payments Protocol A2A
extension, this agent was built directly using the A2A framework.

The core logic of how an A2A agent processes requests and generates responses is
handled by an AgentExecutor. The BaseServerExecutor handles the common task of
interpreting the user's request, identifying the appropriate tool to use, and
invoking it to complete a task.
"""


import logging
from typing import Any

from a2a.server.tasks.task_updater import TaskUpdater
from a2a.types import Part
from a2a.types import Task
from a2a.types import TextPart

from . import tools
from .sub_agents import catalog_agent
from common import message_utils
from common.base_server_executor import BaseServerExecutor
from common.system_utils import DEBUG_MODE_INSTRUCTIONS


# A list of known Shopping Agent identifiers that this Merchant is willing to
# work with.
_KNOWN_SHOPPING_AGENTS = [
    "trusted_shopping_agent",
]

class MerchantAgentExecutor(BaseServerExecutor):
  """AgentExecutor for the merchant agent."""

  _system_prompt = """
    You are a merchant agent. Your role is to help users with their shopping
    requests.

    You can find items, update shopping carts, and initiate payments.

    %s
  """ % DEBUG_MODE_INSTRUCTIONS

  def __init__(self, supported_extensions: list[dict[str, Any]] = None):
    """Initializes the MerchantAgentExecutor.

    Args:
        supported_extensions: A list of extension objects supported by the
          agent.
    """
    agent_tools = [
        tools.update_cart,
        catalog_agent.find_items_workflow,
        tools.initiate_payment,
        tools.dpc_finish,
    ]
    super().__init__(supported_extensions, agent_tools, self._system_prompt)

  async def _handle_request(
      self,
      text_parts: list[str],
      data_parts: list[dict[str, Any]],
      updater: TaskUpdater,
      current_task: Task | None,
  ) -> None:
    """Overrides the base class method to validate the shopping agent first."""
    if not await self._validate_shopping_agent(data_parts, updater):
      error_message = updater.new_agent_message(
          parts=[
              Part(root=TextPart(text=f"Failed to validate shopping agent."))
          ]
      )
      await updater.failed(message=error_message)
      return
    await super()._handle_request(text_parts, data_parts, updater, current_task)

  async def _validate_shopping_agent(
      self, data_parts: list[dict[str, Any]], updater: TaskUpdater
  ) -> None:
    """Validates that the incoming request is from a trusted Shopping Agent.

    Args:
      data_parts: A list of data part contents from the request.

    Returns:
      True if the Shopping Agent is trusted, or False if not.
    """

    shopping_agent_id = message_utils.find_data_part(
        "shopping_agent_id", data_parts
    )
    logging.info(
        "Received request from shopping_agent_id: %s", shopping_agent_id
    )

    if not shopping_agent_id:
      logging.warning("Missing shopping_agent_id in request.")
      await _fail_task(
          updater, "Unauthorized Request: Missing shopping_agent_id."
      )
      return False

    if shopping_agent_id not in _KNOWN_SHOPPING_AGENTS:
      logging.warning("Unknown Shopping Agent: %s", shopping_agent_id)
      await _fail_task(
          updater, f"Unauthorized Request: Unknown agent '{shopping_agent_id}'."
      )
      return False

    logging.info(
        "Authorized request from shopping_agent_id: %s", shopping_agent_id
    )
    return True


async def _fail_task(updater: TaskUpdater, error_text: str) -> None:
  """A helper function to fail a task with a given error message."""
  error_message = updater.new_agent_message(
      parts=[Part(root=TextPart(text=error_text))]
  )
  await updater.failed(message=error_message)


--- Content of roles/merchant_agent/storage.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""In-memory storage for CartMandates.

A CartMandate may be updated multiple times during the course of a shopping
journey. This storage system is used to persist CartMandates between
interactions between the shopper and merchant agents.
"""

from typing import Optional

from ap2.types.mandate import CartMandate


def get_cart_mandate(cart_id: str) -> Optional[CartMandate]:
  """Get a cart mandate by cart ID."""
  return _store.get(cart_id)


def set_cart_mandate(cart_id: str, cart_mandate: CartMandate) -> None:
  """Set a cart mandate by cart ID."""
  _store[cart_id] = cart_mandate


def set_risk_data(context_id: str, risk_data: str) -> None:
  """Set risk data by context ID."""
  _store[context_id] = risk_data


def get_risk_data(context_id: str) -> Optional[str]:
  """Get risk data by context ID."""
  return _store.get(context_id)


_store = {}


--- Content of roles/merchant_agent/__main__.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Main for the merchant agent."""

from collections.abc import Sequence

from absl import app

from roles.merchant_agent.agent_executor import MerchantAgentExecutor
from common import server

AGENT_MERCHANT_PORT = 8001

def main(argv: Sequence[str]) -> None:
  agent_card = server.load_local_agent_card(__file__)
  server.run_agent_blocking(
      port=AGENT_MERCHANT_PORT,
      agent_card=agent_card,
      executor=MerchantAgentExecutor(agent_card.capabilities.extensions),
      rpc_url="/a2a/merchant_agent",
  )

if __name__ == "__main__":
  app.run(main)


--- Content of roles/merchant_agent/__pycache__/storage.cpython-312.pyc ---



    lh                     x    d Z ddlmZ ddlmZ dedee   fdZdededdfd	Zd
ededdfdZd
edee   fd
Z	i Z
y)zIn-memory storage for CartMandates.

A CartMandate may be updated multiple times during the course of a shopping
journey. This storage system is used to persist CartMandates between
interactions between the shopper and merchant agents.
    )Optional)CartMandatecart_idreturnc                 ,    t         j                  |       S )zGet a cart mandate by cart ID._storeget)r   s    P/Users/heikohotz/Projects/AP2/samples/python/src/roles/merchant_agent/storage.pyget_cart_mandater      s    	G	    cart_mandateNc                     |t         | <   y)zSet a cart mandate by cart ID.Nr	   )r   r   s     r   set_cart_mandater       s     &/r
   
context_id	risk_datac                     |t         | <   y)zSet risk data by context ID.Nr   )r   r   s     r   
set_risk_datar   %   s     &r
   c                 ,    t         j                  |       S )zGet risk data by context ID.r   )r   s    r   
get_risk_datar   *   s    	J	r
   )__doc__typingr   ap2.types.mandater   strr   r   r   r   r	    r
   r   <module>r      s|     )c h{&; 
!c ! ! !
!c !c !d !
 c  hsm  
 
r
   

--- Content of roles/merchant_agent/__pycache__/agent_executor.cpython-312.pyc ---



    lh+                         d Z ddlZddlmZ ddlmZ ddlmZ ddlmZ ddlm	Z	 dd	l
mZ dd
lm
Z
 ddlmZ ddlmZ dd
lmZ dgZ G d de      ZdededdfdZy)a  A merchant agent executor for handling user shopping requests.

This agent's role is to:
1. Route user intent to a catalog for product discovery.
2. Handle requests to update a shopping cart.
3. Forward payment requests to the appropriate payment processor.

In order to clearly demonstrate the use of the Agent Payments Protocol A2A
extension, this agent was built directly using the A2A framework.

The core logic of how an A2A agent processes requests and generates responses is
handled by an AgentExecutor. The BaseServerExecutor handles the common task of
interpreting the user's request, identifying the appropriate tool to use, and
invoking it to complete a task.
    N)Any)TaskUpdater)Part)Task)TextPart   )tools)
catalog_agent)
message_utils)BaseServerExecutor)DEBUG_MODE_INSTRUCTIONStrusted_shopping_agentc            
            e Zd ZdZdez  Zd
deeee	f      f fd
Z
dee   deeee	f      ded	edz  d
df
 fdZ
deeee	f      ded
dfdZ xZS )MerchantAgentExecutorz%AgentExecutor for the merchant agent.z
    You are a merchant agent. Your role is to help users with their shopping
    requests.

    You can find items, update shopping carts, and initiate payments.

    %s
  Nsupported_extensionsc                     t         j                  t        j                  t         j                  t         j
                  g}t        |   ||| j                         y)zInitializes the MerchantAgentExecutor.

    Args:
        supported_extensions: A list of extension objects supported by the
          agent.
    N)	r	   update_cartr
   find_items_workflowinitiate_payment
dpc_finishsuper__init___system_prompt)selfr   agent_tools	__class__s      W/Users/heikohotz/Projects/AP2/samples/python/src/roles/merchant_agent/agent_executor.pyr   zMerchantAgentExecutor.__init__A   sJ     	))

	K 
G);8K8KL    
text_parts
data_partsupdatercurrent_taskreturnc                   K   | j                  ||       d{   sB|j                  t        t        d            g      }|j	                  |       d{    yt
        |   ||||       d{    y7 a7 "7 	w)zEOverrides the base class method to validate the shopping agent first.Nz"Failed to validate shopping agent.textrootpartsmessage)_validate_shopping_agentnew_agent_messager   r   failedr   _handle_request)r   r   r    r!   r"   
error_messager   s         r   r0   z%MerchantAgentExecutor._handle_requestP   s      ..z7CCC//(JLM 0 m
 
NN=N111
'
!*j'<
PPP D 2Ps4   BA;A BA=B5A?6B=B?Bc                 ^  K   t        j                  d|      }t        j                  d|       |s*t        j                  d       t        |d       d{    y|t        vr/t        j                  d|       t        |d| d	       d{    yt        j                  d
|       y7 S7 w)zValidates that the incoming request is from a trusted Shopping Agent.

    Args:
      data_parts: A list of data part contents from the request.

    Returns:
      True if the Shopping Agent is trusted, or False if not.
    shopping_agent_idz+Received request from shopping_agent_id: %sz%Missing shopping_agent_id in request.z0Unauthorized Request: Missing shopping_agent_id.NFzUnknown Shopping Agent: %sz%Unauthorized Request: Unknown agent 'z'.z-Authorized request from shopping_agent_id: %sT)r   find_data_partlogginginfowarning
_fail_task_KNOWN_SHOPPING_AGENTS)r   r    r!   r3   s       r   r-   z.MerchantAgentExecutor._validate_shopping_agentb   s      &44Z LL57H 
oo=>
E
    66
oo24EF
:;L:MRP
   LL79J s$   AB-B)6B-B+
B-+B-)N)__name__
__module____qualname____doc__r
   r   listdictstrr   r   r   r   r0   r-   
__classcell__)r   s   @r   r   r   5   s    - 	  .
M4S#X+? 
MQs)Q tCH~&Q 	Q
 4KQ 
Q$$T#s(^,$7B$$r   r   r!   
error_textr#   c                    K   | j                  t        t        |            g      }| j                  |       d{    y7 w)z<A helper function to fail a task with a given error message.r%   r'   r)   r+   N)r.   r   r   r/   )r!   rB   r1   s      r   r8   r8      sA     ++
xZ0
12 , - 	}---s   =AA A)r=   r5   typingr   a2a.server.tasks.task_updaterr   	a2a.typesr   r   r    r	   
sub_agentsr
   commonr   common.base_server_executorr   common.system_utilsr
   r9   r   r@   r8    r   r   <module>rM      sd   "   5     %   : 7  Q. Qh.k .s .t .r   

--- Content of roles/merchant_agent/__pycache__/__main__.cpython-312.pyc ---



    lhs                         d Z ddlmZ ddlmZ ddlmZ ddlmZ dZ	dee
   dd	fd
Zedk(  r ej                  e       y	y	)zMain for the merchant agent.    )Sequence)app)MerchantAgentExecutor)serveriA  argvreturnNc                     t        j                  t              }t        j                  t        |t        |j                  j                        d       y )Nz/a2a/merchant_agent)port
agent_cardexecutorrpc_url)r   load_local_agent_card__file__run_agent_blockingAGENT_MERCHANT_PORTr   capabilities
extensions)r   r   s     Q/Users/heikohotz/Projects/AP2/samples/python/src/roles/merchant_agent/__main__.pymainr      s=    ++H5*$Z%<%<%G%GH#	    __main__)__doc__collections.abcr   abslr   #roles.merchant_agent.agent_executorr   commonr   r   strr   __name__run r   r   <module>r!      sO    # $  E  x}   z	#''$- r   

--- Content of roles/merchant_agent/__pycache__/tools.cpython-312.pyc ---



    lho#                        d Z ddlZddlZddlZddlmZ ddlmZ ddlm	Z	 ddl
mZ ddl
mZ ddl
m
Z
 dd	l
mZ d
dlmZ ddlmZ dd
lmZ ddlmZ ddlmZ ddlmZ ddlmZ ddlmZ ddlmZ ddlmZ ddl m!Z! ddiZ"dZ#	 d%de$e%e&ef      de	de
dz  de'ddf
dZ(	 d%de$e%e&ef      de	de
dz  de'ddf
dZ)de$e%e&ef      de	de
dz  ddfd Z*d!e
dz  de&dz  fd"Z+de	d#e&ddfd$Z,y)&zTools used by the merchant agent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process.
    N)ValidationError)Any)TaskUpdater)DataPart)Part)Task)TextPart   )storage)ContactAddress)CART_MANDATE_DATA_KEY)PAYMENT_MANDATE_DATA_KEY)PaymentMandate)PaymentCurrencyAmount)PaymentItem)
message_utils)
EXTENSION_URI)A2aMessageBuilder)PaymentRemoteA2aClientCARDz:http://localhost:8003/a2a/merchant_payment_processor_agentz%eyJhbGciOiJSUzI1NiIsImtpZIwMjQwOTA...
data_partsupdatercurrent_task
debug_modereturnc           	      .  K   t        j                  d|       }|st        |d       d{    yt        j                  d|       }|st        |d       d{    yt        j                  |      }|st        |d|        d{    yt        j
                  |j                        }|s"t        |d|j                          d{    y	 t        j                  |      |j                  j                  _        t        dt        d	d
            t        d
t        d	d            g}|j                  j                  }	|	j                  j                  ||	j                  _        n%|	j                  j                  j!                  |       t#        d |	j                  j                  D              |	j                  j$                  j&                  _        t*        |_        |j/                  t1        t3        t4        |j7                         i            t1        t3        d|i            g       d{    |j9                          d{    y7 -7 7 7 7 )7 # t:        $ r"}
t        |d|
        d{  7   Y d}
~
yd}
~
ww xY ww)aL  Updates an existing cart after a shipping address is provided.

  Args:
    data_parts: A list of data part contents from the request.
    updater: The TaskUpdater instance to add artifacts and complete the task.
    current_task: The current task -- not used in this function.
    debug_mode: Whether the agent is in debug mode.
  cart_idzMissing cart_id.Nshipping_addresszMissing shipping_address.z#CartMandate not found for cart_id: z"Missing risk_data for context_id: ShippingUSDg       @)currencyvalue)labelamountTaxg      ?c              3   H   K   | ]  }|j                   j                    y w)N)r$   r"   ).0items     N/Users/heikohotz/Projects/AP2/samples/python/src/roles/merchant_agent/tools.py	<genexpr>zupdate_cart.<locals>.<genexpr>z   s      5&Kd&Ks    "dataroot	risk_dataz"Invalid CartMandate after update: )r   find_data_part
_fail_taskr   get_cart_mandate
get_risk_data
context_idr   model_validatecontentspayment_requestr   r   r   details
display_itemsextendsumtotalr$   r"   	_FAKE_JWTmerchant_authorizationadd_artifactr   r   r
   
model_dumpcompleter   )r   r   r   r   r   r   cart_mandater/   tax_and_shipping_costsr7   es              r)   update_cartrE   9   sz     
((J?'	
W0
111
"11* 

W9
:::
))'2,	
W CG9M
NNN
##G$6$67)	
5g6H6H5IJ   -H 	%%&67 )): 	(%tD	
 	(%tD	
	 #++;;O,,4.Do+++223IJ 25 5&5&=&=&K&K5 2O!!((. +4L'


+\-D-D-FG	

 	
(i 89:
     


C 2 ;
 O
P 	 H
W B1#F
GGGHs   (JI,JI.JIAJ	I 
JE)I' 9I#:I' I%I' JJJ J#I' %I' '	J0J
JJ
J
JJc                   K   t        j                  t        | t              }|st	        |d       d{    yt        j
                  d|       }|st	        |d       d{    y|j                  j                  j                  }t        j                  |      }|st	        |d|        d{    yt        d|t        h      }t               j                  |j                        j!                  d      j#                  t        |j%                               j#                  d|      j#                  d	|      }	t        j
                  d
|       xs d}
|
r|	j#                  d
|
       t'        |      }|r|	j)                  |       |j+                  |	j-                                d{   }|j/                  |j0                  j2                  |j0                  j4                         d{    y7 7 7 J7 Q7 w)
a  Initiates a payment for a given payment mandate. Use to make a payment.

  Args:
    data_parts: The data parts from the request, expected to contain a
      PaymentMandate and optionally an challenge response.
    updater: The TaskUpdater instance for updating the task state.
    current_task: The current task, used to find the processor's task ID.
    debug_mode: Whether the agent is in debug mode.
  zMissing payment_mandate.Nr/   zMissing risk_data.z'No payment processor found for method: payment_processor_agent)namebase_urlrequired_extensionsinitiate_paymentr   challenge_response )statemessage)r   parse_canonical_objectr   r   r1   r0   payment_mandate_contentspayment_responsemethod_name*_PAYMENT_PROCESSORS_BY_PAYMENT_METHOD_TYPEgetr   r   r   set_context_idr4   add_textadd_datar@   _get_payment_processor_task_idset_task_idsend_a2a_messagebuild
update_statusstatusrN   rO   )
r   r   r   r   payment_mandater/   payment_method_type
processor_urlrG   message_builderrL   payment_processor_task_idtasks
                r)   rK   rK      s     "88
N/ 

W8
999
**;
C)	
W2
333
 ..??KK  =@@- 

:;N:OP   2$
 ~g(()x"#x(/*D*D*FGxY'xj)
  ""#7DJ  13EF<\J 9:&778M8M8OP	P$KKkk!! 	 	  c :
 4@ 
QsZ   1H G3,H  G6!AH /G90C:H *G<+AH -G>.H 6H 9H <H >H c           	      0  K   t        j                  d|       }|st        |d       d{    yt        j                  d|       |j                  t
        t        ddd      	      g       d{    |j                          d{    y7 e7 7 	w)
a  Receives and validates a DPC response to finalize payment.

  This tool receives the Digital Payment Credential (DPC) response, in the form
  of an OpenID4VP JSON, validates it, and simulates payment finalization.

  Args:
    data_parts: A list of data part contents from the request.
    updater: The TaskUpdater instance to add artifacts and complete the task.
    current_task: The current task, not used in this function.
  dpc_responsezMissing dpc_response.Nz*Received DPC response for finalization: %sSUCCESStxn_1234567890)payment_statustransaction_idr+   r-   )	r   r0   r1   logginginfor?   r   r   rA   )r   r   r   rf   s       r)   
dpc_finishrm      s      --njI,	
W5
666
	,,;\J 	
%, 	 
 	   	# 7 s4   (BBAB2B3B
BBBBrd   c                 z    | y| j                   D ])  }|j                  | j                  k7  s|j                  c S  y)zReturns the task ID of the payment processor task, if it exists.

  Identified by assuming the first message with a task ID that is not the
  merchant's task ID is a payment processor message.
  N)historytask_idid)rd   rO   s     r)   rY   rY      s9     
\g$''!
__  
    
error_textc                    K   | j                  t        t        |            g      }| j                  |       d{    y7 w)z<A helper function to fail a task with a given error message.)textr-   )parts)rO   N)new_agent_messager   r	   failed)r   rs   
error_messages      r)   r1   r1   
  sA     ++
xZ0
12 , - 	}---s   =AA A)F)-__doc__base64jsonrk   pydanticr   typingr   a2a.server.tasks.task_updaterr   	a2a.typesr   r   r   r	   rM   r   ap2.types.contact_pickerr   ap2.types.mandater
   r   r   ap2.types.payment_requestr   r   commonr   common.a2a_extension_utilsr   common.a2a_message_builderr    common.payment_remote_a2a_clientr   rT   r=   listdictstrboolrE   rK   rm   rY   r1    rr   r)   <module>r      sx      $  5      3 3 6 , ; 1   4 8 C H. *
 
4	 	THT#s(^$TH
TH +TH 	TH
 
THv 	GT#s(^$G
G +G 	G
 
GT"T#s(^$"
" +" 
	"J t .k .s .t .rr   

--- Content of roles/merchant_agent/sub_agents/__init__.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


--- Content of roles/merchant_agent/sub_agents/catalog_agent.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A sub-agent that offers items from its 'catalog'.

This agent fabricates catalog content based on the user's request.
"""

from datetime import datetime
from datetime import timedelta
from datetime import timezone
import os
from typing import Any

from a2a.server.tasks.task_updater import TaskUpdater
from a2a.types import DataPart
from a2a.types import Part
from a2a.types import Task
from a2a.types import TextPart
from google import genai
from pydantic import ValidationError

from .. import storage
from ap2.types.mandate import CART_MANDATE_DATA_KEY
from ap2.types.mandate import CartContents
from ap2.types.mandate import CartMandate
from ap2.types.mandate import INTENT_MANDATE_DATA_KEY
from ap2.types.mandate import IntentMandate
from ap2.types.payment_request import PaymentDetailsInit
from ap2.types.payment_request import PaymentItem
from ap2.types.payment_request import PaymentMethodData
from ap2.types.payment_request import PaymentOptions
from ap2.types.payment_request import PaymentRequest
from common import message_utils
from common import system_utils
from common.system_utils import DEBUG_MODE_INSTRUCTIONS


async def find_items_workflow(
    data_parts: list[dict[str, Any]],
    updater: TaskUpdater,
    current_task: Task | None,
) -> None:
  """Finds products that match the user's IntentMandate."""
  system_utils.check_google_api_key()
  llm_client = genai.Client(api_key=os.getenv("GOOGLE_API_KEY"))

  intent_mandate = message_utils.parse_canonical_object(
      INTENT_MANDATE_DATA_KEY, data_parts, IntentMandate
  )
  intent = intent_mandate.natural_language_description
  prompt = f"""
        Based on the user's request for '{intent}', your task is to generate 3
        complete, unique and realistic PaymentItem JSON objects.

        You MUST exclude all branding from the PaymentItem `label` field.

    %s
        """ % DEBUG_MODE_INSTRUCTIONS

  llm_response = llm_client.models.generate_content(
      model="gemini-2.5-flash",
      contents=prompt,
      config={
          "response_mime_type": "application/json",
          "response_schema": list[PaymentItem],
      }
  )
  try:
    items: list[PaymentItem] = llm_response.parsed

    current_time = datetime.now(timezone.utc)
    item_count = 0
    for item in items:
      item_count += 1
      await _create_and_add_cart_mandate_artifact(
          item, item_count, current_time, updater
      )
    risk_data = _collect_risk_data(updater)
    updater.add_artifact([
        Part(root=DataPart(data={"risk_data": risk_data})),
    ])
    await updater.complete()
  except ValidationError as e:
    error_message = updater.new_agent_message(
        parts=[Part(root=TextPart(text=f"Invalid CartMandate list: {e}"))]
    )
    await updater.failed(message=error_message)
    return


async def _create_and_add_cart_mandate_artifact(
    item: PaymentItem,
    item_count: int,
    current_time: datetime,
    updater: TaskUpdater,
) -> None:
  """Creates a CartMandate and adds it as an artifact."""
  payment_request = PaymentRequest(
      method_data=[
          PaymentMethodData(
              supported_methods="CARD",
              data={
                  "network": ["mastercard", "paypal", "amex"],
              },
          )
      ],
      details=PaymentDetailsInit(
          id=f"order_{item_count}",
          display_items=[item],
          total=PaymentItem(
              label="Total",
              amount=item.amount,
          ),
      ),
      options=PaymentOptions(request_shipping=True),
  )

  cart_contents = CartContents(
      id=f"cart_{item_count}",
      user_cart_confirmation_required=True,
      payment_request=payment_request,
      cart_expiry=(current_time + timedelta(minutes=30)).isoformat(),
      merchant_name="Generic Merchant",
  )

  cart_mandate = CartMandate(contents=cart_contents)

  storage.set_cart_mandate(cart_mandate.contents.id, cart_mandate)
  await updater.add_artifact([
      Part(
          root=DataPart(data={CART_MANDATE_DATA_KEY: cart_mandate.model_dump()})
      )
  ])


def _collect_risk_data(updater: TaskUpdater) -> dict:
  """Creates a risk_data in the tool_context."""
  # This is a fake risk data for demonstration purposes.
  risk_data = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...fake_risk_data"
  storage.set_risk_data(updater.context_id, risk_data)
  return risk_data


--- Content of roles/merchant_agent/sub_agents/__pycache__/catalog_agent.cpython-312.pyc ---



    lh@              
          d Z ddlmZ ddlmZ ddlmZ ddlZddlmZ ddlmZ ddl	m
Z
 dd	l	mZ dd
l	mZ ddl	m
Z
 ddlmZ dd
lmZ ddlmZ ddlmZ ddlmZ ddlmZ ddlmZ ddlmZ ddlmZ ddlmZ ddlmZ ddlmZ ddlmZ ddl m!Z! ddl m"Z" ddl#m$Z$ de%e&e'ef      dededz  d dfd!Z(d"ed#e)d$eded df
d%Z*ded e&fd&Z+y)'zvA sub-agent that offers items from its 'catalog'.

This agent fabricates catalog content based on the user's request.
    )datetime)	timedelta)timezoneN)Any)TaskUpdater)DataPart)Part)Task)TextPart)genai)ValidationError   )storage)CART_MANDATE_DATA_KEY)CartContents)CartMandate)INTENT_MANDATE_DATA_KEY)
IntentMandate)PaymentDetailsInit)PaymentItem)PaymentMethodData)PaymentOptions)PaymentRequest)
message_utils)system_utils)DEBUG_MODE_INSTRUCTIONS
data_partsupdatercurrent_taskreturnc           	      J  K   t        j                          t        j                  t	        j
                  d            }t
        j                  t        | t              }|j                  }d| dt        z  }|j                  j                  d|dt        t           d      }	 |j                   }t#        j$                  t&        j(                        }	d	}
|D ]  }|
d
z
  }
t+        ||
|	|       d{     t-        |      }|j/                  t1        t3        d|i
            g       |j5                          d{    y7 R7 # t6        $ rO}
|j9                  t1        t;        d|
             g      }|j=                  |       d{  7   Y d}
~
yd}
~
ww xY ww)z3Finds products that match the user's IntentMandate.GOOGLE_API_KEY)api_keyz*
        Based on the user's request for 'z', your task is to generate 3
        complete, unique and realistic PaymentItem JSON objects.

        You MUST exclude all branding from the PaymentItem `label` field.

    %s
        zgemini-2.5-flashzapplication/json)response_mime_typeresponse_schema)modelcontentsconfigr      N	risk_datadatarootzInvalid CartMandate list: )text)parts)message)r   check_google_api_keyr   Clientosgetenvr   parse_canonical_objectr   r   natural_language_descriptionr   modelsgenerate_contentlistr   parsedr   nowr   utc%_create_and_add_cart_mandate_artifact_collect_risk_dataadd_artifactr	   r   completer
   new_agent_messager   failed)r   r   r   
llm_clientintent_mandateintentpromptllm_responseitemscurrent_time
item_countitemr*   e
error_messages                  a/Users/heikohotz/Projects/AP2/samples/python/src/roles/merchant_agent/sub_agents/catalog_agent.pyfind_items_workflowrP   2   s     ##%||BII.>$?@* 77z=. 66&**0 2	 &&& ""33 2!+. 4 ,+22E<<-LJAoj1

L'
   
 #7+I(i 89:  


 	 --)CA3'GHIJ . M ...
///
sb   B"F#%AE 1E2AE >E?E F#E E 	F ?FFFF#F  F#rL   rK   rJ   c                   K   t        t        ddg di      gt        d| | gt        d| j                              t        d	
            }t
        d| d	||t        d
      z   j                         d      }t        |      }t        j                  |j                  j                  |       |j                  t        t!        t"        |j%                         i            g       d{    y7 w)z1Creates a CartMandate and adds it as an artifact.CARDnetwork)
mastercardpaypalamex)supported_methodsr,   order_Total)labelamount)id
display_itemstotalT)request_shipping)method_datadetailsoptionscart_   )minuteszGeneric Merchant)r\   user_cart_confirmation_requiredpayment_requestcart_expiry
merchant_name)r'   r+   r-   N)r   r   r   r   r[   r   r   r   	isoformatr   r   set_cart_mandater'   r\   r@   r	   r   r   
model_dump)rL   rK   rJ   r   rg   
cart_contentscart_mandates          rO   r>   r>   g   s      #
 &= !j\
"[[ d3#/( 	&*%)B"77BBD&- m4,	<0033\B
3\5L5L5NOP 	  s   C/C91C72C9c                 J    d}t        j                  | j                  |       |S )z(Creates a risk_data in the tool_context.z5eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...fake_risk_data)r   
set_risk_data
context_id)r   r*   s     rO   r?   r?      s&     F)	**I6	    ),__doc__r   r   r   r4   typingr   a2a.server.tasks.task_updaterr   	a2a.typesr   r	   r
   r   googler   pydanticr
    r   ap2.types.mandater   r   r   r   r   ap2.types.payment_requestr   r   r   r   r   commonr   r   common.system_utilsr   r:   dictstrrP   intr>   r?    rr   rO   <module>r      s   
    	  5      $  3 * ) 5 + 8 1 7 4 4    72T#s(^$2
2 +2 
	2j*
** * 	*
 
*Z  rr   

--- Content of roles/merchant_agent/sub_agents/__pycache__/__init__.cpython-312.pyc ---



    lh?                          y )N r       \/Users/heikohotz/Projects/AP2/samples/python/src/roles/merchant_agent/sub_agents/__init__.py<module>r      s   r   

--- Content of roles/credentials_provider_agent/tools.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tools for the credentials provider agent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process.
"""

from typing import Any

from a2a.server.tasks.task_updater import TaskUpdater
from a2a.types import DataPart
from a2a.types import Part
from a2a.types import Task

from . import account_manager
from ap2.types.contact_picker import CONTACT_ADDRESS_DATA_KEY
from ap2.types.mandate import PAYMENT_MANDATE_DATA_KEY
from ap2.types.mandate import PaymentMandate
from ap2.types.payment_request import PAYMENT_METHOD_DATA_DATA_KEY
from ap2.types.payment_request import PaymentMethodData
from common import message_utils


async def handle_get_shipping_address(
    data_parts: list[dict[str, Any]],
    updater: TaskUpdater,
    current_task: Task | None,
) -> None:
  """Handles a request to get the user's shipping address.

  Updates a task with the user's shipping address if found.

  Args:
    data_parts: DataPart contents. Should contain a single user_email.
    updater: The TaskUpdater instance for updating the task state.
    current_task: The current task if there is one.
  """
  user_email = message_utils.find_data_part("user_email", data_parts)
  if not user_email:
    raise ValueError("user_email is required for get_shipping_address")
  shipping_address = account_manager.get_account_shipping_address(user_email)
  await updater.add_artifact(
      [Part(root=DataPart(data={CONTACT_ADDRESS_DATA_KEY: shipping_address}))]
  )
  await updater.complete()


async def handle_search_payment_methods(
    data_parts: list[dict[str, Any]],
    updater: TaskUpdater,
    current_task: Task | None,
) -> None:
  """Returns the user's payment methods that match what the merchant accepts.

  The merchant's accepted payment methods are provided in the data_parts as a
  list of PaymentMethodData objects.  The user's account is identified by the
  user_email provided in the data_parts.

  This tool finds and returns all the payment methods associated with the user's
  account that match the merchant's accepted payment methods.

  Args:
    data_parts: DataPart contents. Should contain a single user_email and a
      list of PaymentMethodData objects.
    updater: The TaskUpdater instance for updating the task state.
    current_task: The current task if there is one.
  """
  user_email = message_utils.find_data_part("user_email", data_parts)
  method_data = message_utils.find_data_parts(
      PAYMENT_METHOD_DATA_DATA_KEY, data_parts
  )
  if not user_email:
    raise ValueError(
        "user_email is required for search_payment_methods"
    )
  if not method_data:
    raise ValueError("method_data is required for search_payment_methods")

  merchant_method_data_list = [
      PaymentMethodData.model_validate(data) for data in method_data
  ]
  eligible_aliases = _get_eligible_payment_method_aliases(
      user_email, merchant_method_data_list
  )
  await updater.add_artifact([Part(root=DataPart(data=eligible_aliases))])
  await updater.complete()


async def handle_get_payment_method_raw_credentials(
    data_parts: list[dict[str, Any]],
    updater: TaskUpdater,
    current_task: Task | None,
) -> None:
  """Exchanges a payment token for the payment method's raw credentials.

  Updates a task with the payment credentials.

  Args:
    data_parts: DataPart contents. Should contain a single PaymentMandate.
    updater: The TaskUpdater instance for updating the task state.
    current_task: The current task if there is one.
  """

  payment_mandate_contents = message_utils.parse_canonical_object(
      PAYMENT_MANDATE_DATA_KEY, data_parts, PaymentMandate
  ).payment_mandate_contents

  token = payment_mandate_contents.payment_response.details.get(
      "token", {}
  ).get("value", "")
  payment_mandate_id = payment_mandate_contents.payment_mandate_id

  payment_method = account_manager.verify_token(token, payment_mandate_id)
  if not payment_method:
    raise ValueError(f"Payment method not found for token: {token}")
  await updater.add_artifact([Part(root=DataPart(data=payment_method))])
  await updater.complete()


async def handle_create_payment_credential_token(
    data_parts: list[dict[str, Any]],
    updater: TaskUpdater,
    current_task: Task | None,
) -> None:
  """Handles a request to get a payment credential token.

  Updates a task with the payment credential token.

  Args:
    data_parts: DataPart contents. Should contain the user_email and
      payment_method_alias.
    updater: The TaskUpdater instance for updating the task state.
    current_task: The current task if there is one.
  """
  user_email = message_utils.find_data_part("user_email", data_parts)
  payment_method_alias = message_utils.find_data_part(
      "payment_method_alias", data_parts
  )
  if not user_email or not payment_method_alias:
    raise ValueError(
        "user_email and payment_method_alias are required for"
        " create_payment_credential_token"
    )

  tokenized_payment_method = account_manager.create_token(
      user_email, payment_method_alias
  )

  await updater.add_artifact(
      [Part(root=DataPart(data={"token": tokenized_payment_method}))]
  )
  await updater.complete()


async def handle_signed_payment_mandate(
    data_parts: list[dict[str, Any]],
    updater: TaskUpdater,
    current_task: Task | None,
) -> None:
  """Handles a signed payment mandate.

  Adds the payment mandate id to the token in storage and then completes the
  task.

  Args:
    data_parts: DataPart contents. Should contain a single PaymentMandate.
    updater: The TaskUpdater instance for updating the task state.
    current_task: The current task if there is one.
  """
  payment_mandate = message_utils.parse_canonical_object(
      PAYMENT_MANDATE_DATA_KEY, data_parts, PaymentMandate
  )
  token = payment_mandate.payment_mandate_contents.payment_response.details.get(
      "token", {}
  ).get("value", "")
  payment_mandate_id = (
      payment_mandate.payment_mandate_contents.payment_mandate_id
  )
  account_manager.update_token(token, payment_mandate_id)
  await updater.complete()


def _get_payment_method_aliases(
    payment_methods: list[dict[str, Any]],
) -> list[str | None]:
  """Gets the payment method aliases from a list of payment methods."""
  return [payment_method.get("alias") for payment_method in payment_methods]


def _get_eligible_payment_method_aliases(
    user_email: str, merchant_accepted_payment_methods: list[PaymentMethodData]
) -> dict[str, list[str | None]]:
  """Gets the payment_methods eligible according to given PaymentMethodData.

  Args:
    user_email: The email address of the user's account.
    merchant_accepted_payment_methods: A list of eligible payment method
      criteria.

  Returns:
    A list of the user's eligible payment_methods.
  """
  payment_methods = account_manager.get_account_payment_methods(user_email)
  eligible_payment_methods = []

  for payment_method in payment_methods:
    for criteria in merchant_accepted_payment_methods:
      if _payment_method_is_eligible(payment_method, criteria):
        eligible_payment_methods.append(payment_method)
        break
  return {
      "payment_method_aliases": _get_payment_method_aliases(
          eligible_payment_methods
      )
  }


def _payment_method_is_eligible(
    payment_method: dict[str, Any], merchant_criteria: PaymentMethodData
) -> bool:
  """Checks if a payment method is eligible based on a PaymentMethodData.

  Args:
    payment_method: A dictionary representing the payment method.
    merchant_criteria: A PaymentMethodData object containing the eligibility
      criteria.

  Returns:
    True if the payment_method is eligible according to the payment method,
    False otherwise.
  """
  if payment_method.get("type", "") != merchant_criteria.supported_methods:
    return False

  merchant_supported_networks = [
      network.casefold()
      for network in merchant_criteria.data.get("network", [])
  ]
  if not merchant_supported_networks:
    return False

  payment_card_networks = payment_method.get("network", [])
  for network_info in payment_card_networks:
    for supported_network in merchant_supported_networks:
      if network_info.get("name", "").casefold() == supported_network:
        return True
  return False


--- Content of roles/credentials_provider_agent/agent.json ---

{
  "name": "CredentialsProvider",
  "description": "An agent that holds a user's payment credentials.",
  "capabilities": {
      "extensions": [
        {
          "uri": "https://github.com/google-agentic-commerce/ap2/v1",
          "description": "Supports the Agent Payments Protocol.",
          "required": true
        },
        {
          "uri": "https://sample-card-network.github.io/paymentmethod/types/v1",
          "description": "Supports the Sample Card Network payment method extension",
          "required": true
        }
      ]
  },
  "skills": [
    {
      "id": "initiate_payment",
      "name": "Initiate Payment",
      "description": "Initiates a payment with the correct payment processor.",
      "tags": ["payments"]
    },
    {
      "id": "get_eligible_payment_methods",
      "name": "Get Eligible Payment Methods",
      "description": "Provides a list of eligible payment methods for a particular purchase.",
      "parameters": {
        "type": "object",
        "properties": {
          "email_address": {
            "type": "string",
            "description": "The email address associated with the user's account."
          }
        },
        "required": ["email_address"]
      },
      "tags": ["eligible", "payment", "methods"]
    },
    {
      "id": "get_account_shipping_address",
      "name": "Get Shipping Address",
      "description": "Fetches the shipping address from a user's wallet.",
      "parameters": {
        "type": "object",
        "properties": {
          "email_address": {
            "type": "string",
            "description": "The email address associated with the user's account."
          }
        },
        "required": ["email_address"]
      },
      "tags": ["account", "shipping"]
    }
  ],
  "defaultInputModes": ["text/plain"],
  "defaultOutputModes": ["application/json"],
  "url": "http://localhost:8002/a2a/credentials_provider",
  "version": "1.0.0"
}


--- Content of roles/credentials_provider_agent/account_manager.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""An in-memory manager of a user's 'account details'.

Each 'account' contains a user's payment methods and shipping address.
For demonstration purposes, several accounts are pre-populated with sample data.
"""

from typing import Any


_account_db = {
    "bugsbunny@gmail.com": {
        "shipping_address": {
            "recipient": "Bugs Bunny",
            "organization": "Sample Organization",
            "address_line": ["123 Main St"],
            "city": "Sample City",
            "region": "ST",
            "postal_code": "00000",
            "country": "US",
            "phone_number": "+1-000-000-0000",
        },
        "payment_methods": {
            "card1": {
                "type": "CARD",
                "alias": "American Express ending in 4444",
                "network": [{"name": "amex", "formats": ["DPAN"]}],
                "cryptogram": "fake_cryptogram_abc123",
                "token": "1111000000000000",
                "card_holder_name": "John Doe",
                "card_expiration": "12/2025",
                "card_billing_address": {
                    "country": "US",
                    "postal_code": "00000",
                },
            },
            "card2": {
                "type": "CARD",
                "alias": "American Express ending in 8888",
                "network": [{"name": "amex", "formats": ["DPAN"]}],
                "cryptogram": "fake_cryptogram_ghi789",
                "token": "2222000000000000",
                "card_holder_name": "Bugs Bunny",
                "card_expiration": "10/2027",
                "card_billing_address": {
                    "country": "US",
                    "postal_code": "00000",
                },
            },
            "bank_account1": {
                "type": "BANK_ACCOUNT",
                "account_number": "111",
                "alias": "Primary bank account",
            },
            "digital_wallet1": {
                "type": "DIGITAL_WALLET",
                "brand": "PayPal",
                "account_identifier": "foo@bar.com",
                "alias": "Bugs's PayPal account",
            },
        },
    },
    "daffyduck@gmail.com": {
        "payment_methods": {
            "bank_account1": {
                "type": "BANK_ACCOUNT",
                "brand": "Bank of Money",
                "account_number": "789",
                "alias": "Main checking account",
            }
        },
    },
    "elmerfudd@gmail.com": {
        "payment_methods": {
            "digital_wallet1": {
                "type": "DIGITAL_WALLET",
                "brand": "PayPal",
                "account_identifier": "elmerfudd@gmail.com",
                "alias": "Fudd's PayPal",
            }
        }
    },
}


_token = {}


def create_token(email_address: str, payment_method_alias: str) -> str:
  """Creates and stores a token for an account.

  Args:
    email_address: The email address of the account.
    payment_method_alias: The alias of the payment method.

  Returns:
    The token for the payment method.
  """
  token = f"fake_payment_credential_token_{len(_token)}"

  _token[token] = {
      "email_address": email_address,
      "payment_method_alias": payment_method_alias,
      "payment_mandate_id": None,
  }

  return token


def update_token(token: str, payment_mandate_id: str) -> None:
  """Updates the token with the payment mandate id.

  Args:
    token: The token to update.
    payment_mandate_id: The payment mandate id to associate with the token.
  """
  if token not in _token:
    raise ValueError(f"Token {token} not found")
  if _token[token].get("payment_mandate_id"):
    # Do not overwrite the payment mandate id if it is already set.
    return
  _token[token]["payment_mandate_id"] = payment_mandate_id

def verify_token(token: str, payment_mandate_id: str) -> dict[str, Any]:
  """Look up an account by token.

  Args:
    token: The token for look up.
    payment_mandate_id: The payment mandate id associated with the token.

  Returns:
    The account for the given token, or status:invalid_token if the token is not
    valid.
  """
  account_lookup = _token.get(token, {})
  if not account_lookup:
    raise ValueError("Invalid token")
  if account_lookup.get("payment_mandate_id") != payment_mandate_id:
    raise ValueError("Invalid token")
  email_address = account_lookup.get("email_address")
  alias = account_lookup.get("payment_method_alias")
  return get_payment_method_by_alias(email_address, alias)


def get_account_payment_methods(email_address: str) -> list[dict[str, Any]]:
  """Returns a list of the payment methods for the given account email address.

  Args:
    email_address: The account's email address.

  Returns:
    A list of the user's payment_methods.
  """

  return list(
      _account_db.get(email_address, {}).get("payment_methods", {}).values()
  )


def get_account_shipping_address(email_address: str) -> dict[str, Any]:
  """Gets the shipping address associated for the given account email address.

  Args:
    email_address: The account's email address.

  Returns:
    The account's shipping address.
  """

  return _account_db.get(email_address, {}).get("shipping_address", {})


def get_payment_method_by_alias(
    email_address: str, alias: str
) -> dict[str, Any] | None:
  """Returns the payment method for a given account and alias.

  Args:
    email_address: The account's email address.
    alias: The alias of the payment method to retrieve.

  Returns:
    The payment method for the given account and alias, or status:not_found.
  """

  payment_methods = list(
      filter(
          lambda payment_method: payment_method.get("alias").casefold()
          == alias.casefold(),
          get_account_payment_methods(email_address),
      )
  )
  if not payment_methods:
    return None
  return payment_methods[0]


--- Content of roles/credentials_provider_agent/agent_executor.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""An A2A Agent Executor for the credentials provider agent.

A credentials provider has several roles:
1. Manage a user's payment credentials & shipping address.
2. Find available payment methods for a particular purchase.
3. Provide a payment credential token for a specific payment method.
4. Provide payment credentials to a processor for completion of a payment.

In order to clearly demonstrate the use of the Agent Payments Protocol A2A 
extension, this agent was built directly using the A2A framework. 

The core logic of how an A2A agent processes requests and generates responses is
handled by an AgentExecutor. The BaseServerExecutor handles the common task of
interpreting the user's request, identifying the appropriate tool to use, and
invoking it to complete a task.
"""

from typing import Any

from . import tools
from common.base_server_executor import BaseServerExecutor
from common.system_utils import DEBUG_MODE_INSTRUCTIONS



class CredentialsProviderExecutor(BaseServerExecutor):
  """AgentExecutor for the credentials provider agent."""

  _system_prompt = """
    You are a credentials provider agent acting as a secure digital wallet.
    Your job is to manage a user's payment methods and shipping addresses.

    Based on the user's request, identify their intent and select the
    single correct tool to use. Your only output should be a tool call.
    Do not engage in conversation.

    %s
  """ % DEBUG_MODE_INSTRUCTIONS

  def __init__(self, supported_extensions: list[dict[str, Any]] = None):
    """Initializes the CredentialsProviderExecutor.

    Args:
        supported_extensions: A list of extension objects supported by the
          agent.
    """

    agent_tools = [
        tools.handle_create_payment_credential_token,
        tools.handle_get_payment_method_raw_credentials,
        tools.handle_get_shipping_address,
        tools.handle_search_payment_methods,
        tools.handle_signed_payment_mandate,
    ]
    super().__init__(supported_extensions, agent_tools, self._system_prompt)


--- Content of roles/credentials_provider_agent/__main__.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A credentials provider."""

from collections.abc import Sequence

from absl import app
from roles.credentials_provider_agent.agent_executor import CredentialsProviderExecutor
from common import server

AGENT_PORT = 8002


def main(argv: Sequence[str]) -> None:
  agent_card = server.load_local_agent_card(__file__)
  server.run_agent_blocking(
      port=AGENT_PORT,
      agent_card=agent_card,
      executor=CredentialsProviderExecutor(agent_card.capabilities.extensions),
      rpc_url="/a2a/credentials_provider",
  )


if __name__ == "__main__":
  app.run(main)


--- Content of roles/credentials_provider_agent/__pycache__/agent_executor.cpython-312.pyc ---



    lh9
                     N    d Z ddlmZ ddlmZ ddlmZ ddlmZ  G d de      Z	y	)
a  An A2A Agent Executor for the credentials provider agent.

A credentials provider has several roles:
1. Manage a user's payment credentials & shipping address.
2. Find available payment methods for a particular purchase.
3. Provide a payment credential token for a specific payment method.
4. Provide payment credentials to a processor for completion of a payment.

In order to clearly demonstrate the use of the Agent Payments Protocol A2A 
extension, this agent was built directly using the A2A framework. 

The core logic of how an A2A agent processes requests and generates responses is
handled by an AgentExecutor. The BaseServerExecutor handles the common task of
interpreting the user's request, identifying the appropriate tool to use, and
invoking it to complete a task.
    )Any   )tools)BaseServerExecutor)DEBUG_MODE_INSTRUCTIONSc                   D     e Zd ZdZdez  Zddeeee	f      f fd
Z
 xZS )CredentialsProviderExecutorz1AgentExecutor for the credentials provider agent.aT  
    You are a credentials provider agent acting as a secure digital wallet.
    Your job is to manage a user's payment methods and shipping addresses.

    Based on the user's request, identify their intent and select the
    single correct tool to use. Your only output should be a tool call.
    Do not engage in conversation.

    %s
  supported_extensionsc                     t         j                  t         j                  t         j                  t         j                  t         j
                  g}t        |   ||| j                         y)zInitializes the CredentialsProviderExecutor.

    Args:
        supported_extensions: A list of extension objects supported by the
          agent.
    N)	r   &handle_create_payment_credential_token)handle_get_payment_method_raw_credentialshandle_get_shipping_addresshandle_search_payment_methodshandle_signed_payment_mandatesuper__init___system_prompt)selfr
   agent_tools	__class__s      c/Users/heikohotz/Projects/AP2/samples/python/src/roles/credentials_provider_agent/agent_executor.pyr   z$CredentialsProviderExecutor.__init__6   sS     	44
77
))
++
++K 
G);8K8KL    )N)__name__
__module____qualname____doc__r   r   listdictstrr   r   
__classcell__)r   s   @r   r	   r	   (   s8    9	 	 	 .M4S#X+? M Mr   r	   N)
r   typingr    r   common.base_server_executorr   common.system_utilsr   r	    r   r   <module>r&      s'   "   : 7M"4 Mr   

--- Content of roles/credentials_provider_agent/__pycache__/account_manager.cpython-312.pyc ---



    lh$                     f   d Z ddlmZ dddgdddd	d
ddd
ddgdgddddd	dddddddgdgddddd	ddddddddd d!d"d#d$d%d&d'dd(d)d*d+iid&d,dd d-d.d#iid/Zi Zd0ed1ed2efd3Zd4ed5ed2d6fd7Zd4ed5ed2eeef   fd8Z	d0ed2e
eeef      fd9Zd0ed2eeef   fd:Zd0ed;ed2eeef   d6z  fd<Z
y6)=zAn in-memory manager of a user's 'account details'.

Each 'account' contains a user's payment methods and shipping address.
For demonstration purposes, several accounts are pre-populated with sample data.
    )Anyz
Bugs BunnyzSample Organizationz123 Main StzSample CityST00000USz+1-000-000-0000)	recipientorganizationaddress_linecityregionpostal_codecountryphone_numberCARDzAmerican Express ending in 4444amexDPAN)nameformatsfake_cryptogram_abc1231111000000000000zJohn Doez12/2025)r
   r   )typealiasnetwork
cryptogramtokencard_holder_namecard_expirationcard_billing_addresszAmerican Express ending in 8888fake_cryptogram_ghi7892222000000000000z10/2027BANK_ACCOUNT111zPrimary bank account)r   account_numberr   DIGITAL_WALLETPayPalzfoo@bar.comzBugs's PayPal account)r   brandaccount_identifierr   )card1card2
bank_account1digital_wallet1)shipping_addresspayment_methodsr,   r)   z
Bank of Money789zMain checking account)r   r%   r"   r   r*   elmerfudd@gmail.comz
Fudd's PayPal)zbugsbunny@gmail.comzdaffyduck@gmail.comr.   
email_addresspayment_method_aliasreturnc                 D    dt        t               }| |ddt        |<   |S )zCreates and stores a token for an account.

  Args:
    email_address: The email address of the account.
    payment_method_alias: The alias of the payment method.

  Returns:
    The token for the payment method.
  fake_payment_credential_token_N)r/   r0   payment_mandate_id)len_token)r/   r0   r   s      d/Users/heikohotz/Projects/AP2/samples/python/src/roles/credentials_provider_agent/account_manager.pycreate_tokenr8   f   s1     
+3v;-
8% %2 &- 
,    r   r4   Nc                 |    | t         vrt        d|  d      t         |    j                  d      ry|t         |    d<   y)zUpdates the token with the payment mandate id.

  Args:
    token: The token to update.
    payment_mandate_id: The payment mandate id to associate with the token.
  zToken z
 not foundr4   N)r6   
ValueErrorget)r   r4   s     r7   update_tokenr=   {   sE     &
veWJ/
00E]+,
(:&-$%r9   c                     t         j                  | i       }|st        d      |j                  d      |k7  rt        d      |j                  d      }|j                  d      }t        ||      S )zLook up an account by token.

  Args:
    token: The token for look up.
    payment_mandate_id: The payment mandate id associated with the token.

  Returns:
    The account for the given token, or status:invalid_token if the token is not
    valid.
  z
Invalid tokenr4   r/   r0   )r6   r<   r;   get_payment_method_by_alias)r   r4   account_lookupr/   r   s        r7   verify_tokenrA      sp     ::eR(.	
_
%%,-1CC
_
%% $$_5-


3
4%	$]E	::r9   c                 |    t        t        j                  | i       j                  di       j                               S )zReturns a list of the payment methods for the given account email address.

  Args:
    email_address: The account's email address.

  Returns:
    A list of the user's payment_methods.
  r,   )list_account_dbr<   valuesr/   s    r7   get_account_payment_methodsrG      s6     
oomR(,,->CJJL
 r9   c                 N    t         j                  | i       j                  di       S )zGets the shipping address associated for the given account email address.

  Args:
    email_address: The account's email address.

  Returns:
    The account's shipping address.
  r+   )rD   r<   rF   s    r7   get_account_shipping_addressrI      s#     
	+	/	/0BB	GGr9   r   c                 V    t        t        fdt        |                   }|sy|d   S )a  Returns the payment method for a given account and alias.

  Args:
    email_address: The account's email address.
    alias: The alias of the payment method to retrieve.

  Returns:
    The payment method for the given account and alias, or status:not_found.
  c                 d    | j                  d      j                         j                         k(  S )Nr   )r<   casefold)payment_methodr   s    r7   <lambda>z-get_payment_method_by_alias.<locals>.<lambda>   s(    !3!3G!<!E!E!G
^^
"r9   Nr   )rC   filterrG   )r/   r   r,   s    ` r7   r?   r?      s7     
%m
4/ 
		r9   )__doc__typingr   rD   r6   strr8   r=   dictrA   rC   rG   rI   r?    r9   r7   <module>rU      s    &1*O!"-	
 :%+AB6+$.#,##*) :%+AB6+$0#,##*) '"'/ )!&30	 A&
2h 	&("'0	
	 	(!&;(	 
	}HV 
 3 3 *; ; ; ;; ; ;c3h ;*s tDcN7K 
H 
HS#X 
H"	#s(^dr9   

--- Content of roles/credentials_provider_agent/__pycache__/__main__.cpython-312.pyc ---



    lh{                         d Z ddlmZ ddlmZ ddlmZ ddlmZ dZ	dee
   dd	fd
Zedk(  r ej                  e       y	y	)zA credentials provider.    )Sequence)app)CredentialsProviderExecutor)serveriB  argvreturnNc                     t        j                  t              }t        j                  t        |t        |j                  j                        d       y )Nz/a2a/credentials_provider)port
agent_cardexecutorrpc_url)r   load_local_agent_card__file__run_agent_blocking
AGENT_PORTr   capabilities
extensions)r   r   s     ]/Users/heikohotz/Projects/AP2/samples/python/src/roles/credentials_provider_agent/__main__.pymainr      s=    ++H5**:+B+B+M+MN)	    __main__)__doc__collections.abcr   abslr   /roles.credentials_provider_agent.agent_executorr   commonr   r   strr   __name__run r   r   <module>r!      sN     $  W 

x}   z	#''$- r   

--- Content of roles/credentials_provider_agent/__pycache__/tools.cpython-312.pyc ---



    lh"              
          d Z ddlmZ ddlmZ ddlmZ ddlmZ ddlmZ ddl	m
Z
 dd	lmZ dd
l
mZ ddl
mZ ddlmZ dd
lmZ ddlmZ deeeef      dededz  ddfdZdeeeef      dededz  ddfdZdeeeef      dededz  ddfdZdeeeef      dededz  ddfdZdeeeef      dededz  ddfdZdeeeef      deedz     fdZdedee   deeeedz     f   fdZdeeef   dedefd Z y)!zTools for the credentials provider agent.

Each agent uses individual tools to handle distinct tasks throughout the
shopping and purchasing process.
    )Any)TaskUpdater)DataPart)Part)Task   )account_manager)CONTACT_ADDRESS_DATA_KEY)PAYMENT_MANDATE_DATA_KEY)PaymentMandate)PAYMENT_METHOD_DATA_DATA_KEY)PaymentMethodData)
message_utils
data_partsupdatercurrent_taskNreturnc                   K   t        j                  d|       }|st        d      t        j                  |      }|j                  t
        t        t        |i            g       d{    |j                          d{    y7 7 w)a<  Handles a request to get the user's shipping address.

  Updates a task with the user's shipping address if found.

  Args:
    data_parts: DataPart contents. Should contain a single user_email.
    updater: The TaskUpdater instance for updating the task state.
    current_task: The current task if there is one.
  
user_emailz/user_email is required for get_shipping_addressdatarootN)
r   find_data_part
ValueErrorr	   get_account_shipping_addressadd_artifactr   r   r
   complete)r   r   r   r   shipping_addresss        Z/Users/heikohotz/Projects/AP2/samples/python/src/roles/credentials_provider_agent/tools.pyhandle_get_shipping_addressr!   %   s      ++L*E*	
F
GG$AA*M 8:JKLMN	   	 s$   A(B*B+BB
B
Bc                   K   t        j                  d|       }t        j                  t        |       }|st	        d      |st	        d      |D cg c]  }t        j                  |       }}t        ||      }|j                  t        t        |            g       d{    |j                          d{    yc c}w 7 "7 w)a  Returns the user's payment methods that match what the merchant accepts.

  The merchant's accepted payment methods are provided in the data_parts as a
  list of PaymentMethodData objects.  The user's account is identified by the
  user_email provided in the data_parts.

  This tool finds and returns all the payment methods associated with the user's
  account that match the merchant's accepted payment methods.

  Args:
    data_parts: DataPart contents. Should contain a single user_email and a
      list of PaymentMethodData objects.
    updater: The TaskUpdater instance for updating the task state.
    current_task: The current task if there is one.
  r   z1user_email is required for search_payment_methodsz2method_data is required for search_payment_methodsr   r   N)r   r   find_data_partsr
   r   r   model_validate$_get_eligible_payment_method_aliasesr   r   r   r   )r   r   r   r   method_datar   merchant_method_data_listeligible_aliasess           r    handle_search_payment_methodsr)   =   s     ( ++L*E*--"J+ 

;  

I
JJ :E9D&&t,   :+ 	d6F(GHIJJJ Ks0   ACC-7C$C%C<C	=C	Cc                   K   t        j                  t        | t              j                  }|j
                  j                  j                  di       j                  dd      }|j                  }t        j                  ||      }|st        d|       |j                  t        t        |            g       d{    |j                          d{    y7 7 w)aA  Exchanges a payment token for the payment method's raw credentials.

  Updates a task with the payment credentials.

  Args:
    data_parts: DataPart contents. Should contain a single PaymentMandate.
    updater: The TaskUpdater instance for updating the task state.
    current_task: The current task if there is one.
  tokenvalue z$Payment method not found for token: r   r   N)r   parse_canonical_objectr   r   payment_mandate_contentspayment_responsedetailsgetpayment_mandate_idr	   verify_tokenr   r   r   r   r   )r   r   r   r/   r+   r3   payment_methods          r    )handle_get_payment_method_raw_credentialsr6   f   s      +AA
N  #
3
3
;
;
?
?
rC  0BB"//7IJ.	
;E7C
DDdn(EFGHHH Is$   B;C=C>CCCCc                 F  K   t        j                  d|       }t        j                  d|       }|r|st        d      t        j                  ||      }|j                  t
        t        d|i            g       d{    |j                          d{    y7 7 w)aM  Handles a request to get a payment credential token.

  Updates a task with the payment credential token.

  Args:
    data_parts: DataPart contents. Should contain the user_email and
      payment_method_alias.
    updater: The TaskUpdater instance for updating the task state.
    current_task: The current task if there is one.
  r   payment_method_aliaszTuser_email and payment_method_alias are required for create_payment_credential_tokenr+   r   r   N)	r   r   r   r	   create_tokenr   r   r   r   )r   r   r   r   r8   tokenized_payment_methods         r    &handle_create_payment_credential_tokenr;      s      ++L*E*&55j 
/
	+ 
 -99& 	)ABCDE	   	 s$   A=B!?B B!BB!B!c                 V  K   t        j                  t        | t              }|j                  j
                  j                  j                  di       j                  dd      }|j                  j                  }t        j                  ||       |j                          d{    y7 w)aE  Handles a signed payment mandate.

  Adds the payment mandate id to the token in storage and then completes the
  task.

  Args:
    data_parts: DataPart contents. Should contain a single PaymentMandate.
    updater: The TaskUpdater instance for updating the task state.
    current_task: The current task if there is one.
  r+   r,   r-   N)r   r.   r   r   r/   r0   r1   r2   r3   r	   update_tokenr   )r   r   r   payment_mandater+   r3   s         r    handle_signed_payment_mandater?      s      "88
N/ 
2
2
C
C
K
K
O
O
rC  ..AA  u&89s   BB)!B'"B)payment_methodsc                 J    | D cg c]  }|j                  d       c}S c c}w )z?Gets the payment method aliases from a list of payment methods.alias)r2   )r@   r5   s     r    _get_payment_method_aliasesrC      s(     =L	LO..

W
%O	LL	Ls    r   !merchant_accepted_payment_methodsc                     t        j                  |       }g }|D ](  }|D ]!  }t        ||      s|j                  |        ( * dt	        |      iS )a$  Gets the payment_methods eligible according to given PaymentMethodData.

  Args:
    user_email: The email address of the user's account.
    merchant_accepted_payment_methods: A list of eligible payment method
      criteria.

  Returns:
    A list of the user's eligible payment_methods.
  payment_method_aliases)r	   get_account_payment_methods_payment_method_is_eligibleappendrC   )r   rD   r@   eligible_payment_methodsr5   criterias         r    r%   r%      sc     $??
K/'n5	$^X	> ''7
 6 (  ;
"!
     r5   merchant_criteriac                 N   | j                  dd      |j                  k7  ry|j                  j                  dg       D cg c]  }|j                          }}|sy| j                  dg       }|D ]/  }|D ](  }|j                  dd      j                         |k(  s'  y 1 yc c}w )a\  Checks if a payment method is eligible based on a PaymentMethodData.

  Args:
    payment_method: A dictionary representing the payment method.
    merchant_criteria: A PaymentMethodData object containing the eligibility
      criteria.

  Returns:
    True if the payment_method is eligible according to the payment method,
    False otherwise.
  typer-   FnetworknameT)r2   supported_methodsr   casefold)r5   rM   rP   merchant_supported_networkspayment_card_networksnetwork_infosupported_networks          r    rH   rH      s     #'8'J'JJ '++//	2>!>' >  ! 
%(,,Y;+l8			&"	%	.	.	04E	E 9 , 
!s   B")!__doc__typingr   a2a.server.tasks.task_updaterr   	a2a.typesr   r   r   r-   r	   ap2.types.contact_pickerr
   ap2.types.mandater   r   ap2.types.payment_requestr
   r   commonr   listdictstrr!   r)   r6   r;   r?   rC   r%   boolrH    rL   r    <module>re      s    5     = 6 , B 7  T#s(^$
 + 
	0&T#s(^$&
& +& 
	&RT#s(^$
 + 
	> T#s(^$ 
  +  
	 FT#s(^$
 + 
	8M$sCx.)M	#*M8<=N8O	#tC$J
 8cN7H	rL   

--- Content of roles/shopping_agent_flights/tools.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tools for the flight shopping agent."""
from datetime import datetime, timedelta, timezone

# --- CHANGE: Import our new structured mandate ---
from .custom_mandate import FlightConstraints, StructuredIntentMandate

from ap2.types.mandate import INTENT_MANDATE_DATA_KEY
from common.a2a_extension_utils import EXTENSION_URI
from common.a2a_message_builder import A2aMessageBuilder
from common.payment_remote_a2a_client import PaymentRemoteA2aClient
from google.adk.tools.tool_context import ToolContext
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Confirm


# --- CHANGE: Update the tool signature to accept structured parameters ---
def create_and_sign_intent_mandate(
    destination: str,
    max_price: int,
    currency: str,
    tool_context: ToolContext,
) -> str:
    """Creates a structured IntentMandate, asks the user to sign it, and stores it."""
    console = Console()
    console.print(
        "[bold green]Shopping Agent:[/bold green] Creating structured AP2"
        " IntentMandate..."
    )

    # --- CHANGE: Populate the new structured mandate ---
    mandate = StructuredIntentMandate(
        natural_language_description=(
            f"A flight to {destination} for no more than {max_price}"
            f" {currency}."
        ),
        user_cart_confirmation_required=False,
        requires_refundability=True,
        intent_expiry=(
            datetime.now(timezone.utc) + timedelta(days=1)
        ).isoformat(),
        constraints=FlightConstraints(
            destination=destination, max_price=max_price, currency=currency
        ),
    )

    panel = Panel(
        mandate.model_dump_json(indent=2),
        title="[yellow]Generated Structured AP2 IntentMandate[/yellow]",
        border_style="yellow",
    )
    console.print(panel)

    if Confirm.ask(
        "[bold green]Shopping Agent:[/bold green] Please review the structured"
        " mandate. Do you approve and wish to sign it?"
    ):
        tool_context.state["signed_mandate"] = mandate
        console.print("[green]✔ Mandate signed successfully.[/green]")
        return "Mandate signed. The agent is now authorized to proceed."
    else:
        console.print("[red]✖ Mandate rejected. Aborting.[/red]")
        return "User rejected the mandate."


async def execute_purchase(
    destination: str, price_gbp: int, tool_context: ToolContext
) -> str:
    """Attempts to purchase a flight by sending the request to the merchant agent."""
    console = Console()
    console.print("\n----------------------------------------------------")
    console.print(
        "[bold green]Shopping Agent:[/bold green] Attempting to book a flight"
        f" to [cyan]{destination}[/cyan] for [cyan]{price_gbp} GBP[/cyan]..."
    )

    signed_mandate = tool_context.state.get("signed_mandate")
    if not signed_mandate:
        return "ERROR: Cannot execute purchase without a signed mandate."

    flight_merchant = PaymentRemoteA2aClient(
        name="flight_merchant",
        base_url="http://localhost:8004/a2a/flights_merchant",
        required_extensions={EXTENSION_URI},
    )

    message = (
        A2aMessageBuilder()
        .add_text("Process this flight purchase request.")
        .add_data(INTENT_MANDATE_DATA_KEY, signed_mandate.model_dump())
        .add_data(
            "flight_details",
            {"destination": destination, "price_gbp": price_gbp},
        )
        .build()
    )

    task = await flight_merchant.send_a2a_message(message)

    if task.status.state == "completed":
        return f"SUCCESS: {task.status.message.parts[0].root.text}"
    else:
        return f"FAILURE: {task.status.message.parts[0].root.text}"


--- Content of roles/shopping_agent_flights/__init__.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""The flight shopping agent module."""

from . import agent


--- Content of roles/shopping_agent_flights/custom_mandate.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Custom, structured IntentMandate for the flight booking demo."""

from ap2.types.mandate import IntentMandate
from pydantic import BaseModel, Field


class FlightConstraints(BaseModel):
    """Structured constraints for a flight booking."""
    destination: str = Field(..., description="The flight destination city.")
    max_price: int = Field(..., description="The maximum price for the flight.")
    currency: str = Field(
        "GBP", description="The 3-letter currency code (e.g., GBP)."
    )


class StructuredIntentMandate(IntentMandate):
    """An IntentMandate subclass that includes structured flight constraints."""
    constraints: FlightConstraints


--- Content of roles/shopping_agent_flights/agent.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A shopping agent for booking flights in a human-not-present scenario."""

from . import tools
from common.retrying_llm_agent import RetryingLlmAgent


flight_shopping_agent = RetryingLlmAgent(
    name="flight_shopping_agent",
    model="gemini-2.5-flash",
    instruction="""
    You are a helpful flight booking agent. Your goal is to book a flight
    according to the user's signed instructions, demonstrating how the AP2
    protocol prevents incorrect purchases.

    Here is the exact flow you must follow:
    1.  Greet the user and ask for their flight requirements (destination and max price).
    2.  Once you have the user's intent, call the `create_and_sign_intent_mandate` tool.
        **You MUST extract the destination city, maximum price, and currency from the user's
        request to pass to the tool.**
    3.  After the mandate is signed, inform the user that you will now proceed
        autonomously based on their signed instructions.
    4.  **Simulate a hallucination**: First, you MUST attempt to book a flight to "Dublin"
        for a price of 180 GBP. Call the `execute_purchase` tool with these
        hallucinated values.
    5.  Report the outcome of the first attempt to the user. Explain clearly
        WHY it was blocked by the merchant.
    6.  **Execute correctly**: Now, you MUST attempt to book the correct flight.
        Use the destination "Paris" and a price of 195 GBP. Call the `execute_purchase`
        tool with these correct values.
    7.  Report the final outcome of the correct purchase attempt to the user.
    """,
    tools=[
        tools.create_and_sign_intent_mandate,
        tools.execute_purchase,
    ],
)


--- Content of roles/shopping_agent_flights/__pycache__/agent.cpython-312.pyc ---



    Gh                     d    d Z ddlmZ ddlmZ  edddej
                  ej                  g      Zy	)
zEA shopping agent for booking flights in a human-not-present scenario.   )tools    )RetryingLlmAgentflight_shopping_agentzgemini-2.5-flasha
  
    You are a helpful flight booking agent. Your goal is to book a flight
    according to the user's signed instructions, demonstrating how the AP2
    protocol prevents incorrect purchases.

    Here is the exact flow you must follow:
    1.  Greet the user and ask for their flight requirements (destination and max price).
    2.  Once you have the user's intent, call the `create_and_sign_intent_mandate` tool.
        **You MUST extract the destination city, maximum price, and currency from the user's
        request to pass to the tool.**
    3.  After the mandate is signed, inform the user that you will now proceed
        autonomously based on their signed instructions.
    4.  **Simulate a hallucination**: First, you MUST attempt to book a flight to "Dublin"
        for a price of 180 GBP. Call the `execute_purchase` tool with these
        hallucinated values.
    5.  Report the outcome of the first attempt to the user. Explain clearly
        WHY it was blocked by the merchant.
    6.  **Execute correctly**: Now, you MUST attempt to book the correct flight.
        Use the destination "Paris" and a price of 195 GBP. Call the `execute_purchase`
        tool with these correct values.
    7.  Report the final outcome of the correct purchase attempt to the user.
    )namemodelinstructionr   N)__doc__ r   common.retrying_llm_agentr   create_and_sign_intent_mandateexecute_purchaser        V/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent_flights/agent.py<module>r      sB    L  6 )	 
. 	,,
3 r   

--- Content of roles/shopping_agent_flights/__pycache__/custom_mandate.cpython-312.pyc ---



    <h                     P    d Z ddlmZ ddlmZmZ  G d de      Z G d de      Zy)	z=Custom, structured IntentMandate for the flight booking demo.    )
IntentMandate)	BaseModelFieldc                   l    e Zd ZU dZ edd      Zeed<    edd      Ze	ed<    edd	      Z
eed
<   y)FlightConstraintsz,Structured constraints for a flight booking..zThe flight destination city.)descriptiondestinationz!The maximum price for the flight.	max_priceGBPz'The 3-letter currency code (e.g., GBP).currencyN)__name__
__module____qualname____doc__r   r	   str__annotations__r
   intr        _/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent_flights/custom_mandate.pyr   r      s@    6S.LMKM3,OPIsP
DHc r   r   c                       e Zd ZU dZeed<   y)StructuredIntentMandatezFAn IntentMandate subclass that includes structured flight constraints.constraintsN)r
   r   r   r   r   r   r   r   r   r   r      s    P""r   r   N)r   ap2.types.mandater   pydanticr   r   r   r   r   r   r   <module>r      s)    D + %	 #m #r   

--- Content of roles/shopping_agent_flights/__pycache__/__init__.cpython-312.pyc ---



    ^:h}                         d Z ddlmZ y)z!The flight shopping agent module.   )agentN)__doc__ r        Y/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent_flights/__init__.py<module>r	      s
    ( r   

--- Content of roles/shopping_agent_flights/__pycache__/tools.cpython-312.pyc ---



    Gh              
           d Z ddlmZmZmZ ddlmZmZ ddlmZ ddl	m
Z
 ddlmZ ddl
mZ dd	lmZ dd
lmZ ddlmZ ddlmZ d
ededededef
dZd
edededefdZy)z$Tools for the flight shopping agent.    )datetime	timedeltatimezone   )FlightConstraintsStructuredIntentMandate)INTENT_MANDATE_DATA_KEY)
EXTENSION_URI)A2aMessageBuilder)PaymentRemoteA2aClient)ToolContext)Console)Panel)Confirmdestination	max_pricecurrencytool_contextreturnc                    t               }|j                  d       t        d|  d| d| dddt        j                  t
        j                        t        d	      z   j                         t        | ||
            }t        |j                  d
      dd      }|j                  |       t        j                  d      r!||j                  d<   |j                  d       y|j                  d       y)zLCreates a structured IntentMandate, asks the user to sign it, and stores it.zQ[bold green]Shopping Agent:[/bold green] Creating structured AP2 IntentMandate...zA flight to z for no more than  .FTr   )days)r   r   r   )natural_language_descriptionuser_cart_confirmation_requiredrequires_refundability
intent_expiryconstraints   )indentz7[yellow]Generated Structured AP2 IntentMandate[/yellow]yellow)titleborder_stylezr[bold green]Shopping Agent:[/bold green] Please review the structured mandate. Do you approve and wish to sign it?signed_mandateu/   [green]✔ Mandate signed successfully.[/green]z7Mandate signed. The agent is now authorized to proceed.u*   [red]✖ Mandate rejected. Aborting.[/red]zUser rejected the mandate.)r   printr   r   nowr   utcr   	isoformatr   r   model_dump_jsonr   askstate)r   r   r   r   consolemandatepanels          V/Users/heikohotz/Projects/AP2/samples/python/src/roles/shopping_agent_flights/tools.pycreate_and_sign_intent_mandater0       s     iGMM	 &;-'9)z
 ).#LL&)::
)+%#y8

G 
q)G
E
 MM%{{	8 07+,

GHH

BC+    	price_gbpc                   K   t               }|j                  d       |j                  d|  d| d       |j                  j                  d      }|syt	        ddt
        h	      }t
               j                  d
      j                  t        |j                               j                  d| |d      j                         }|j                  |       d
{   }|j                  j                  dk(  r:d|j                  j                  j                  d   j                   j"                   S d|j                  j                  j                  d   j                   j"                   S 7 w)zKAttempts to purchase a flight by sending the request to the merchant agent.z5
----------------------------------------------------zN[bold green]Shopping Agent:[/bold green] Attempting to book a flight to [cyan]z[/cyan] for [cyan]z GBP[/cyan]...r$   z8ERROR: Cannot execute purchase without a signed mandate.flight_merchantz*http://localhost:8004/a2a/flights_merchant)namebase_urlrequired_extensionsz%Process this flight purchase request.flight_details)r   r2   N	completedz	SUCCESS: r   z	FAILURE: )r   r%   r+   getr   r
   r   add_textadd_datar	   
model_dumpbuildsend_a2a_messagestatusmessagepartsroottext)r   r2   r   r,   r$   r4   rA   tasks           r/   execute_purchaserF   P   sK     iGMMJKMM	 M!3I;n	N
 "''++,<=NI,
=*OO 		9	:	)>+D+D+F	G	'i@

 
  !11'::D{{K'4;;..44Q7<<AABCC4;;..44Q7<<AABCC ;s   CE+E)BE+N)__doc__r   r   r   custom_mandater   r   ap2.types.mandater	   common.a2a_extension_utilsr
   common.a2a_message_builderr    common.payment_remote_a2a_clientr   google.adk.tools.tool_contextr
   rich.consoler   
rich.panelr   rich.promptr   strintr0   rF    r1   r/   <module>rT      s    + 2 2 G 5 4 8 C 5    -,-,-, -, 	-,
 	-,`%D%D!$%D4?%D%Dr1   

--- Content of roles/merchant_agent_flights/tools.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tools for the flight merchant agent."""
from typing import Any

from a2a.server.tasks.task_updater import TaskUpdater
from a2a.types import DataPart, Part, Task, TextPart
from ap2.types.mandate import INTENT_MANDATE_DATA_KEY, IntentMandate
from common import message_utils
from rich.console import Console
from rich.panel import Panel



# --- CHANGE: Import the structured mandate to validate against it ---
from roles.shopping_agent_flights.custom_mandate import StructuredIntentMandate


async def process_purchase_request(
    data_parts: list[dict[str, Any]],
    updater: TaskUpdater,
    current_task: Task | None,
) -> None:
    """Processes a flight purchase by validating against structured mandate fields."""
    console = Console()
    console.print(
        "[bold blue]Flight Merchant:[/bold blue] Received purchase request..."
    )

    try:
        # --- CHANGE: Validate against our custom structured model ---
        mandate_data = message_utils.find_data_part(
            INTENT_MANDATE_DATA_KEY, data_parts
        )
        if not mandate_data:
            raise ValueError("IntentMandate not found in request.")
        structured_mandate = StructuredIntentMandate.model_validate(
            mandate_data
        )

        flight_details = message_utils.find_data_part(
            "flight_details", data_parts
        )
        if not flight_details:
            raise ValueError("Missing flight_details in request.")

        console.print(
            "[bold blue]Flight Merchant:[/bold blue] Verifying purchase"
            " against [yellow]structured[/yellow] IntentMandate fields..."
        )

        # --- CHANGE: Validate against structured constraints ---
        # 1. Validate destination
        mandate_destination = structured_mandate.constraints.destination
        if flight_details["destination"].lower() != mandate_destination.lower():
            msg = (
                "Purchase Blocked: Destination Mismatch. Agent tried to book a"
                f" flight to '{flight_details['destination']}', but the signed"
                " mandate only authorizes"
                f" '{mandate_destination}'."
            )
            panel = Panel(
                f"Attempted Destination: [red]{flight_details['destination']}[/red]\n"
                "Mandate Constraint: "
                f"[green]{mandate_destination}[/green]\n\n"
                "[bold]Result: VIOLATION DETECTED[/bold]",
                title="[red]Purchase Blocked by Merchant[/red]",
                border_style="red",
            )
            console.print(panel)
            await _fail_task(updater, msg)
            return

        # 2. Validate price
        mandate_max_price = structured_mandate.constraints.max_price
        if flight_details["price_gbp"] > mandate_max_price:
            msg = (
                "Purchase Blocked: Price Exceeds Limit. Agent tried to book for"
                f" {flight_details['price_gbp']} GBP, but the signed mandate"
                " only authorizes up to"
                f" {mandate_max_price} GBP."
            )
            panel = Panel(
                f"Attempted Price: [red]{flight_details['price_gbp']} GBP[/red]\n"
                "Mandate Constraint: "
                f"[green]<= {mandate_max_price} GBP[/green]\n\n"
                "[bold]Result: VIOLATION DETECTED[/bold]",
                title="[red]Purchase Blocked by Merchant[/red]",
                border_style="red",
            )
            console.print(panel)
            await _fail_task(updater, msg)
            return

        # If all checks pass
        success_msg = "Verification successful. Purchase approved!"
        panel = Panel(
            "All purchase details are consistent with the user's signed"
            " structured IntentMandate.",
            title="[green]✔ Purchase Approved by Merchant[/green]",
            border_style="green",
        )
        console.print(panel)
        success_message = updater.new_agent_message(
            parts=[Part(root=TextPart(text=success_msg))]
        )
        await updater.complete(message=success_message)

    except Exception as e:
        console.print(f"[bold red]ERROR:[/bold red] {e}")
        await _fail_task(updater, str(e))


async def _fail_task(updater: TaskUpdater, error_text: str) -> None:
    """Helper function to fail a task with a given error message."""
    error_message = updater.new_agent_message(
        parts=[Part(root=TextPart(text=error_text))]
    )
    await updater.failed(message=error_message)


--- Content of roles/merchant_agent_flights/__init__.py ---



--- Content of roles/merchant_agent_flights/agent.json ---

{
    "name": "FlightMerchantAgent",
    "description": "An agent that sells flights and validates purchase requests against signed mandates.",
    "url": "http://localhost:8004/a2a/flights_merchant",
    "capabilities": {
        "extensions": [
            {
                "uri": "https://github.com/google-agentic-commerce/ap2/v1",
                "description": "Supports the Agent Payments Protocol.",
                "required": true
            }
        ]
    },
    "skills": [
        {
            "id": "process_purchase",
            "name": "Process Flight Purchase",
            "description": "Processes a flight purchase request by validating it against a signed IntentMandate."
        }
    ],
    "version": "1.0.0"
}


--- Content of roles/merchant_agent_flights/agent_executor.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A2A Agent Executor for the flight merchant agent."""

from typing import Any

from . import tools
from common.base_server_executor import BaseServerExecutor


class FlightMerchantExecutor(BaseServerExecutor):
    """AgentExecutor for the flight merchant agent."""

    _system_prompt = """
    You are a merchant agent responsible for selling flights.
    Your only job is to receive purchase requests and validate them.
    Always use the 'process_purchase_request' tool.
    """

    def __init__(self, supported_extensions: list[dict[str, Any]] = None):
        agent_tools = [
            tools.process_purchase_request,
        ]
        super().__init__(supported_extensions, agent_tools, self._system_prompt)


--- Content of roles/merchant_agent_flights/__main__.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Entrypoint for the flight merchant agent."""

from collections.abc import Sequence

from absl import app
from roles.merchant_agent_flights.agent_executor import FlightMerchantExecutor
from common import server

AGENT_PORT = 8004  # Use a new port to avoid conflicts


def main(argv: Sequence[str]) -> None:
    agent_card = server.load_local_agent_card(__file__)
    server.run_agent_blocking(
        port=AGENT_PORT,
        agent_card=agent_card,
        executor=FlightMerchantExecutor(agent_card.capabilities.extensions),
        rpc_url="/a2a/flights_merchant",
    )


if __name__ == "__main__":
    app.run(main)


--- Content of roles/merchant_agent_flights/__pycache__/agent_executor.cpython-312.pyc ---



    :h                     B    d Z ddlmZ ddlmZ ddlmZ  G d de      Zy)	z1A2A Agent Executor for the flight merchant agent.    )Any   )tools)BaseServerExecutorc                   >     e Zd ZdZdZddeeeef      f fd
Z	 xZ
S )FlightMerchantExecutorz,AgentExecutor for the flight merchant agent.z
    You are a merchant agent responsible for selling flights.
    Your only job is to receive purchase requests and validate them.
    Always use the 'process_purchase_request' tool.
    supported_extensionsc                 ^    t         j                  g}t        | 
  ||| j                         y N)r   process_purchase_requestsuper__init___system_prompt)selfr	   agent_tools	__class__s      _/Users/heikohotz/Projects/AP2/samples/python/src/roles/merchant_agent_flights/agent_executor.pyr   zFlightMerchantExecutor.__init__    s-    **
 	-{D<O<OP    r   )__name__
__module____qualname____doc__r   listdictstrr   r   
__classcell__)r   s   @r   r   r      s.    6NQT$sCx.-A Q Qr   r   N)r   typingr    r   common.base_server_executorr   r    r   r   <module>r!      s"    8   :
Q/ 
Qr   

--- Content of roles/merchant_agent_flights/__pycache__/__init__.cpython-312.pyc ---



    :h                            y )N r       Y/Users/heikohotz/Projects/AP2/samples/python/src/roles/merchant_agent_flights/__init__.py<module>r      s   r   

--- Content of roles/merchant_agent_flights/__pycache__/__main__.cpython-312.pyc ---



    :h                         d Z ddlmZ ddlmZ ddlmZ ddlmZ dZ	dee
   dd	fd
Zedk(  r ej                  e       y	y	)z)Entrypoint for the flight merchant agent.    )Sequence)app)FlightMerchantExecutor)serveriD  argvreturnNc                     t        j                  t              }t        j                  t        |t        |j                  j                        d       y )Nz/a2a/flights_merchant)port
agent_cardexecutorrpc_url)r   load_local_agent_card__file__run_agent_blocking
AGENT_PORTr   capabilities
extensions)r   r   s     Y/Users/heikohotz/Projects/AP2/samples/python/src/roles/merchant_agent_flights/__main__.pymainr      s=    --h7J

'
(?(?(J(JK'	    __main__)__doc__collections.abcr   abslr   +roles.merchant_agent_flights.agent_executorr   commonr   r   strr   __name__run r   r   <module>r!      sN    0 $  N 

x}   zCGGDM r   

--- Content of roles/merchant_agent_flights/__pycache__/tools.cpython-312.pyc ---



    k<h                         d Z ddlmZ ddlmZ ddlmZmZmZm	Z	 ddl
mZmZ ddl
mZ ddlmZ ddlmZ dd	lmZ d
eeeef      deded
z  dd
fdZdededd
fdZy
)z$Tools for the flight merchant agent.    )Any)TaskUpdater)DataPartPartTaskTextPart)INTENT_MANDATE_DATA_KEY
IntentMandate)
message_utils)Console)Panel)StructuredIntentMandate
data_partsupdatercurrent_taskNreturnc                 \  K   t               }|j                  d       	 t        j                  t        |       }|st        d      t
        j                  |      }t        j                  d|       }|st        d      |j                  d       |j                  j                  }|d   j                         |j                         k7  rJd|d    d| d	}t        d
|d    d| dd
d      }	|j                  |	       t        ||       d{    y|j                  j                  }
|d   |
kD  rJd|d    d|
 d}t        d|d    d|
 dd
d      }	|j                  |	       t        ||       d{    yd}t        ddd      }	|j                  |	       |j                  t        t!        |            g      }|j#                  |       d{    y7 7 j7 	# t$        $ r<}
|j                  d |
        t        |t'        |
             d{  7   Y d}
~
yd}
~
ww xY ww)!zLProcesses a flight purchase by validating against structured mandate fields.zD[bold blue]Flight Merchant:[/bold blue] Received purchase request...z#IntentMandate not found in request.flight_detailsz"Missing flight_details in request.zv[bold blue]Flight Merchant:[/bold blue] Verifying purchase against [yellow]structured[/yellow] IntentMandate fields...destinationzIPurchase Blocked: Destination Mismatch. Agent tried to book a flight to 'z+', but the signed mandate only authorizes 'z'.zAttempted Destination: [red]z"[/red]
Mandate Constraint: [green]z1[/green]

[bold]Result: VIOLATION DETECTED[/bold]z'[red]Purchase Blocked by Merchant[/red]red)titleborder_styleN	price_gbpz?Purchase Blocked: Price Exceeds Limit. Agent tried to book for z3 GBP, but the signed mandate only authorizes up to z GBP.zAttempted Price: [red]z) GBP[/red]
Mandate Constraint: [green]<= z5 GBP[/green]

[bold]Result: VIOLATION DETECTED[/bold]z+Verification successful. Purchase approved!zTAll purchase details are consistent with the user's signed structured IntentMandate.u0   [green]✔ Purchase Approved by Merchant[/green]greentextrootpartsmessagez[bold red]ERROR:[/bold red] )r   printr   find_data_partr	   
ValueErrorr   model_validateconstraintsr   lowerr
   
_fail_task	max_pricenew_agent_messager   r   complete	Exceptionstr)r   r   r   consolemandate_datastructured_mandater   mandate_destinationmsgpanelmandate_max_pricesuccess_msgsuccess_messagees                 V/Users/heikohotz/Projects/AP2/samples/python/src/roles/merchant_agent_flights/tools.pyprocess_purchase_requestr:      s     iGMMNQ*$33#Z
 BCC4CC
 '55j
 ABB


K	
 1<<HH-(..04G4M4M4OO-m<= >()- 
 .~m/L.M N-. /:: @"
E 
MM% Wc*** /::DD+&)::";/0 1%&e- 
 ()D(E F./ 0:: @"
E 
MM% Wc*** D
)D 	
 	

e!33X;789 4 
 777I 
+* 
+ 	8 *

4QC89#a&)))*s   H,C.G$ 
GG$ H,A"G$ 5G 6G$ :H,;AG$ G"G$ H,G$  G$ "G$ $	H)-,H$HH$H,$H))H,
error_textc                    K   | j                  t        t        |            g      }| j                  |       d{    y7 w)z:Helper function to fail a task with a given error message.r   r   r   r!   N)r+   r   r   failed)r   r;   
error_messages      r9   r)   r)   ~   sA     --z234 . M ...
///s   =AA A)__doc__typingr   a2a.server.tasks.task_updaterr   	a2a.typesr   r   r   r   ap2.types.mandater	   r
   commonr   rich.consoler   
rich.panelr
   +roles.shopping_agent_flights.custom_mandater   listdictr.   r:   r)        r9   <module>rL      s    +  5 4 4 D     
 P\*T#s(^$\*
\* +\* 
	\*~0k 0s 0t 0rK   

--- Content of common/message_utils.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Helper functions for working with A2A Message objects."""

from typing import Any
from pydantic import BaseModel


def find_data_part(
    data_key: str, data_parts: list[dict[str, Any]]
) -> Any | None:
  """Returns the value for the first occurence of the key in the data parts.

  Args:
    data_key: The key to search for.
    data_parts: The data parts to be searched.

  Returns:
    The value for the first occurence of the key in the data parts, or None.
  """
  for data_part in data_parts:
    if data_key in data_part:
      return data_part[data_key]

  return None


def find_data_parts(
    data_key: str, data_parts: list[dict[str, Any]]
) -> list[Any]:
  """Returns a list of all values for the given key in the data parts.

  Args:
    data_key: The key to search for.
    data_parts: The data parts to be searched.

  Returns:
    A list of all values for the given key in the data parts.
  """
  data_parts_with_key = []
  for data_part in data_parts:
    if data_key in data_part:
      data_parts_with_key.append(data_part[data_key])

  return data_parts_with_key


def parse_canonical_object(
    data_key: str,
    data_parts: list[dict[str, Any]],
    canonical_object_model: BaseModel,
) -> Any:
  """Converts the data part value for the given key to a canonical object.

  Args:
    data_key: The key to search for.
    data_parts: The data parts to be searched.
    canonical_object_model: The pydantic model of the canonical object.

  Returns:
    The canonical object created from the data part value.
  """
  canonical_object_data = find_data_part(data_key, data_parts)
  if canonical_object_data is None:
    raise ValueError(f"{type(canonical_object_model)} not found.")
  return canonical_object_model.model_validate(canonical_object_data)


--- Content of common/server.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A server for hosting an A2A agent using Starlette and Uvicorn.

To provide a clear demonstration of the Agent Payments Protocol A2A extension,
this server operates without the Google ADK. Instead, it directly uses an
AgentCard and AgentExecutor to launch a Uvicorn server.
"""

import json
import logging
import os
import pprint

from a2a.server.agent_execution.simple_request_context_builder import SimpleRequestContextBuilder
from a2a.server.apps.jsonrpc.starlette_app import A2AStarletteApplication
from a2a.server.request_handlers.default_request_handler import DefaultRequestHandler
from a2a.server.tasks.inmemory_task_store import InMemoryTaskStore
from a2a.types import AgentCard
from a2a.utils.constants import AGENT_CARD_WELL_KNOWN_PATH
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.middleware.cors import CORSMiddleware
from starlette.requests import Request
from starlette.responses import Response
import uvicorn

from . import watch_log
from .base_server_executor import BaseServerExecutor


def load_local_agent_card(file_path: str) -> AgentCard:
  """Loads the AgentCard from the specified file path.

  Args:
      file_path: The directory where the agent.json file is located.

  Returns:
      The loaded AgentCard instance.
  """
  card_path = os.path.join(os.path.dirname(file_path), "agent.json")
  with open(card_path, "r", encoding="utf-8") as f:
    data = json.load(f)
  return AgentCard.model_validate(data)


def run_agent_blocking(
    port: int,
    agent_card: AgentCard,
    *,
    executor: BaseServerExecutor,
    rpc_url: str,
) -> None:
  """Launches a Uvicorn server for an agent and block the current thread.

  Args:
      port: TCP port to bind to.
      agent_card: The AgentCard object describing the agent.
      executor: The AgentExecutor that processes A2A requests.
      rpc_url: The base URL path at which to mount the JSON-RPC handler.
  """

  # Add a file handler to the logger for watch.log.
  logger = logging.getLogger(__name__)
  logger.addHandler(watch_log.create_file_handler())

  # Build the Starlette app and add middlewares.
  app = _build_starlette_app(agent_card, executor=executor, rpc_url=rpc_url)
  _add_middlewares(app, logger)

  # Start the server.
  logger.info("%s listening on http://localhost:%d", agent_card.name, port)
  uvicorn.run(
      app, host="127.0.0.1", port=port, log_level="info", timeout_keep_alive=120
  )


def _create_watch_log_handler() -> logging.FileHandler:
  """Create a file handler for watch.log logger.

  watch.log is a log file meant to be watched in parallel with running a
  scenario.  It will contain all the requests and responses to/from the agent
  that are sent to/from the client, so engineers can see what is happening
  between the servers in real time.

  Returns:
      A logging.FileHandler instance configured for 'watch.log'.
  """
  file_handler = logging.FileHandler(".logs/watch.log")
  file_handler.setLevel(logging.INFO)
  file_handler.setFormatter(logging.Formatter("%(name)s: %(message)s"))
  return file_handler


class _LoggingMiddleware(BaseHTTPMiddleware):
  """Intercepts and logs incoming request and response details."""

  def __init__(self, *args, logger: logging.Logger, **kwargs):
    self._logger = logger
    super().__init__(*args, **kwargs)

  async def dispatch(self, request: Request, call_next) -> Response:
    self._logger.info("\n\n\n")
    self._logger.info("---------- New Agent Request Received---------")

    # Log the request method and URL.
    self._logger.info("%s %s", request.method, request.url)

    # Log the request body if it's present.
    content_length = request.headers.get("content-length")
    if content_length and int(content_length) > 0:
      request_body = await request.json()
    else:
      request_body = "<empty>"

    self._logger.info("\n")
    self._logger.info("[Request Body]")
    self._logger.info("%s", request_body)

    # If the extension header is present, log a notice.
    # TODO

    response = await call_next(request)

    # Ensure the response has a body to read.
    if response.body_iterator:
      body = b""

      # Read the entire response body.
      # All responses are UTF-8 encoded JSON, so this should always succeed.
      async for chunk in response.body_iterator:
        body += chunk

      try:
        response_body_json = body.decode("utf-8")
      except UnicodeDecodeError:
        self._logger.warning("Failed to decode response body as UTF-8.")
        response_body_json = body

      self._logger.info("\n")
      self._logger.info("[Response Body]")
      self._logger.info("%s", response_body_json)

      return Response(
          content=body,
          status_code=response.status_code,
          media_type=response.media_type,
          headers=response.headers,
      )
    else:
      self._logger.info("\n")
      self._logger.info("[Response Body]")
      self._logger.info("<empty>")
      return response


def _build_starlette_app(
    agent_card: AgentCard, *, executor, rpc_url
) -> A2AStarletteApplication:
  """Create and return a ready-to-serve Starlette ASGI application.

  Args:
      agent_card: The AgentCard object describing the agent.
      executor: The AgentExecutor that processes A2A requests.
      rpc_url: The base URL path at which to mount the JSON-RPC handler.

  Returns:
      An instance of A2AStarletteApplication.

  Raises:
      ValueError: If executor is None.
  """
  if executor is None:
    raise ValueError("executor must be supplied")

  handler = DefaultRequestHandler(
      agent_executor=executor,
      task_store=InMemoryTaskStore(),
      request_context_builder=SimpleRequestContextBuilder(),
  )

  app = A2AStarletteApplication(
      agent_card=agent_card, http_handler=handler
  ).build(
      rpc_url=rpc_url, agent_card_url=f"{rpc_url}{AGENT_CARD_WELL_KNOWN_PATH}"
  )
  return app


def _add_middlewares(app, logger: logging.Logger) -> None:
  """Add middlewares to the Starlette app."""
  app.add_middleware(
      CORSMiddleware,
      allow_origins=[
          "http://localhost:8000",
          "http://127.0.0.1:8000",
          "http://0.0.0.0:8000",
          "http://localhost:8081",
          "http://127.0.0.1:8081",
          "http://0.0.0.0:8081",
          "http://localhost:8082",
          "http://127.0.0.1:8082",
          "http://0.0.0.0:8082",
          "http://localhost:8083",
          "http://127.0.0.1:8083",
          "http://0.0.0.0:8083",
          "http://localhost:8080",
          "http://127.0.0.1:8080",
          "http://0.0.0.0:8080",
      ],
      allow_credentials=True,
      allow_methods=["*"],
      allow_headers=["*"],
  )
  app.add_middleware(_LoggingMiddleware, logger=logger)
  return app


--- Content of common/payment_remote_a2a_client.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Wrapper for the A2A client."""

import httpx
import logging
import uuid

from a2a import types as a2a_types
from a2a.client.card_resolver import A2ACardResolver
from a2a.client.client import Client
from a2a.client.client import ClientConfig
from a2a.client.client_factory import ClientFactory
from a2a.client.client_task_manager import ClientTaskManager
from a2a.extensions.common import HTTP_EXTENSION_HEADER

DEFAULT_TIMEOUT = 600.0


class PaymentRemoteA2aClient():
  """Wrapper for the A2A client.

  Always assumes the AgentCard is at base_url + {AGENT_CARD_WELL_KNOWN_PATH}.

  Provides convenience for establishing connection and for sending messages.
  """

  def __init__(
      self,
      name: str,
      base_url: str,
      required_extensions: set[str] | None = None,
  ):
    """Initializes the PaymentRemoteA2aClient.

    Args:
      name: The name of the agent.
      base_url: The base URL where the remote agent is hosted.
      required_extensions: A set of extension URIs that the client requires.
    """

    self._httpx_client = httpx.AsyncClient(
        timeout=httpx.Timeout(timeout=DEFAULT_TIMEOUT)
    )
    self._a2a_client_factory = ClientFactory(
        ClientConfig(
            httpx_client=self._httpx_client,
        )
    )
    self._name = name
    self._base_url = base_url
    self._agent_card = None
    self._client_required_extensions = required_extensions or set()

  async def get_agent_card(self) -> a2a_types.AgentCard:
    """Get agent card."""
    if self._agent_card is None:
      resolver = A2ACardResolver(
          httpx_client=self._httpx_client,
          base_url=self._base_url,
      )
      self._agent_card = await resolver.get_agent_card()
    return self._agent_card

  async def send_a2a_message(
      self, message: a2a_types.Message
  ) -> a2a_types.Task:
    """Retrieves the A2A client, sends the message, and returns the event."""
    my_a2a_client: Client = await self._get_a2a_client()

    task_manager = ClientTaskManager()

    async for event in my_a2a_client.send_message(message):
      # Tasks are returned in tuples (aka ClientEvent). The first element is the
      # Task, the second element is the UpdateEvent.
      if isinstance(event, tuple):
        event = event[0]
      await task_manager.process(event)

    task = task_manager.get_task()
    if task is None:
      raise RuntimeError(f"No response from {self._name}")
    logging.info(
        "Response received from %s for (context_id, task_id): (%s, %s)",
        self._name,
        task.context_id,
        task.id,
    )
    return task

  async def _get_a2a_client(self) -> Client:
    """Get A2A client."""
    agent_card = await self.get_agent_card()
    self._httpx_client.headers[HTTP_EXTENSION_HEADER] = ", ".join(
        self._client_required_extensions
    )
    return self._a2a_client_factory.create(agent_card)

  def _create_agent_message(
      self,
      message: str,
  ) -> a2a_types.Message:
    """Get message."""
    return a2a_types.Message(
        message_id=uuid.uuid4().hex,
        parts=[a2a_types.Part(root=a2a_types.TextPart(text=str(message)))],
        role=a2a_types.Role.agent,
    )


--- Content of common/base_server_executor.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A baseline A2A AgentExecutor utilized by multiple agents.

This provides some custom abilities over the default AgentExecutor:
1. It accepts a list of supported A2A extensions. Upon receiving a message, it
activates any requested extensions that the agent supports.
2. It leverages the FunctionCallResolver to identify the appropriate tool to
use for a given request, and invoking it to complete the task.
3. It logs key events in the Agent Payments Protocol to the watch log. See
watch_log.py for more details.
"""

import abc
import logging
import os
from typing import Any, Callable, Tuple
import uuid

from a2a.server.agent_execution.agent_executor import AgentExecutor
from a2a.server.agent_execution.context import RequestContext
from a2a.server.events.event_queue import EventQueue
from a2a.server.tasks.task_updater import TaskUpdater
from a2a.types import Part
from a2a.types import Task
from a2a.types import TextPart
from a2a.utils import message
from google import genai
from ap2.types.mandate import PAYMENT_MANDATE_DATA_KEY
from ap2.types.mandate import PaymentMandate
from common import message_utils
from common import system_utils
from common import watch_log
from common.a2a_extension_utils import EXTENSION_URI
from common.function_call_resolver import FunctionCallResolver
from common.validation import validate_payment_mandate_signature

DataPartContent = dict[str, Any]
Tool = Callable[[list[DataPartContent], TaskUpdater, Task | None], Any]

class BaseServerExecutor(AgentExecutor, abc.ABC):
  """A baseline A2A AgentExecutor to be utilized by agents."""

  def __init__(
      self,
      supported_extensions: list[dict[str, Any]] | None,
      tools: list[Tool],
      system_prompt: str = "You are a helpful assistant.",
  ):
    """Initialization.

    Args:
      supported_extensions: Extensions the agent declares that it supports.
      tools: Tools supported by the agent.
      system_prompt: Helps steer the model when choosing tools.
    """
    if supported_extensions is not None:
      self._supported_extension_uris = {ext.uri for ext in supported_extensions}
    else:
      self._supported_extension_uris = set()
    system_utils.check_google_api_key()
    self._client = genai.Client(api_key=os.getenv("GOOGLE_API_KEY"))
    self._tools = tools
    self._tool_resolver = FunctionCallResolver(
        self._client, self._tools, system_prompt
    )
    super().__init__()

  async def execute(
      self, context: RequestContext, event_queue: EventQueue
  ) -> None:
    """Execute the agent's logic for a given request context.

    Args:
      context: The request context containing the message, task ID, etc.
      event_queue: The queue to publish events to.
    """
    watch_log.log_a2a_request_extensions(context)

    text_parts, data_parts = self._parse_request(context)
    watch_log.log_a2a_message_parts(text_parts, data_parts)

    self._handle_extensions(context)

    if EXTENSION_URI in context.call_context.activated_extensions:
      payment_mandate = message_utils.find_data_part(
          PAYMENT_MANDATE_DATA_KEY, data_parts
      )
      if payment_mandate is not None:
        validate_payment_mandate_signature(
            PaymentMandate.model_validate(payment_mandate)
        )
    else:
      raise ValueError(
          "Payment extension not activated."
          f" {context.call_context.activated_extensions}"
      )

    updater = TaskUpdater(
        event_queue,
        task_id=context.task_id or str(uuid.uuid4()),
        context_id=context.context_id or str(uuid.uuid4()),
    )

    logging.info(
        "Server working on (context_id, task_id): (%s, %s)",
        updater.context_id,
        updater.task_id,
    )
    await self._handle_request(
        text_parts,
        data_parts,
        updater,
        context.current_task,
    )

  async def cancel(self, context: RequestContext) -> None:
    """Request the agent to cancel an ongoing task."""
    pass

  async def _handle_request(
      self,
      text_parts: list[str],
      data_parts: list[dict[str, Any]],
      updater: TaskUpdater,
      current_task: Task | None,
  ) -> None:
    """Receives a parsed request and dispatches to the appropriate tool.

    Args:
      text_parts: A list of text parts from the request.
      data_parts: A list of data parts from the request.
      updater: The TaskUpdater instance for updating the task.
      current_task: The current Task, if available.
    """
    try:
      prompt = (text_parts[0] if text_parts else "").strip()
      tool_name = self._tool_resolver.determine_tool_to_use(prompt)
      logging.info("Using tool: %s", tool_name)

      matching_tools = list(
          filter(lambda tool: tool.__name__ == tool_name, self._tools)
      )
      if len(matching_tools) != 1:
        raise ValueError(
            f"Expected 1 tool matching {tool_name}, got {len(matching_tools)}"
        )
      callable_tool = matching_tools[0]
      await callable_tool(data_parts, updater, current_task)

    except Exception as e:  # pylint: disable=broad-exception-caught
      error_message = updater.new_agent_message(
          parts=[Part(root=TextPart(text=f"An error occurred: {e}"))]
      )
      await updater.failed(message=error_message)

  def _parse_request(
      self, context: RequestContext
  ) -> Tuple[list[str], list[dict[str, Any]]]:
    """Parses the request and returns the text and data parts.

    Args:
      context: The A2A RequestContext

    Returns:
      A tuple containing the contents of TextPart and DataPart objects.
    """
    parts = context.message.parts if context.message else []
    text_parts = message.get_text_parts(parts)
    data_parts = message.get_data_parts(parts)
    return text_parts, data_parts

  def _handle_extensions(self, context: RequestContext) -> None:
    """Activates any requested extensions that the agent supports.

    Args:
      context: The A2A RequestContext
    """
    requested_uris = context.requested_extensions
    activated_uris = requested_uris.intersection(self._supported_extension_uris)
    for uri in activated_uris:
      context.add_activated_extension(uri)


--- Content of common/watch_log.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Utility methods related to creating the watch.log file.

The watch.log file is a log file meant to be watched in parallel with running a
scenario.  It will contain all the requests and responses to/from the agent
that are sent to/from the client, so engineers can see what is happening
between the servers in real time.
"""

import logging
from typing import Any

from a2a.server.agent_execution.context import RequestContext

from ap2.types.mandate import CART_MANDATE_DATA_KEY
from ap2.types.mandate import INTENT_MANDATE_DATA_KEY
from ap2.types.mandate import PAYMENT_MANDATE_DATA_KEY

_logger = logging.getLogger(__name__)


def create_file_handler() -> logging.FileHandler:
  """Creates a file handler to the logger for watch.log.

  Returns:
      A logging.FileHandler instance configured for 'watch.log'.
  """
  file_handler = logging.FileHandler(".logs/watch.log")
  file_handler.setLevel(logging.INFO)
  file_handler.setFormatter(logging.Formatter("%(message)s"))
  return file_handler


def log_a2a_message_parts(
    text_parts: list[str], data_parts: list[dict[str, Any]]
):
  _load_logger()

  """Logs the A2A message parts to the watch.log file."""
  _log_request_instuctions(text_parts)
  _log_mandates(data_parts)
  _log_extra_data(data_parts)


def log_a2a_request_extensions(context: RequestContext) -> None:
  """Logs the A2A extensions activated to the watch.log file."""

  if not context.call_context.activated_extensions:
    return

  _logger.info("\n")
  _logger.info("[A2A Extensions Activated in the Request]")

  for extension in context.call_context.requested_extensions:
    _logger.info(extension)


def _load_logger():
  if not _logger.handlers:
    _logger.addHandler(create_file_handler())


def _log_request_instuctions(text_parts: list[str]) -> None:
  """Logs the request instructions from the text parts."""
  _logger.info("\n")
  _logger.info("[Request Instructions]")
  _logger.info(text_parts)


def _log_mandates(data_parts: list[dict[str, Any]]) -> None:
  """Extracts and logs mandates from the data parts."""

  for data_part in data_parts:
    for key, value in data_part.items():
      if key == CART_MANDATE_DATA_KEY:
        _logger.info("\n")
        _logger.info("[A Cart Mandate was in the request Data]")
        _logger.info(value)
      elif key == INTENT_MANDATE_DATA_KEY:
        _logger.info("\n")
        _logger.info("[An Intent Mandate was in the request Data]")
        _logger.info(value)
      elif key == PAYMENT_MANDATE_DATA_KEY:
        _logger.info("\n")
        _logger.info("[A Payment Mandate was in the request Data]")
        _logger.info(value)


def _log_extra_data(data_parts: list[dict[str, Any]]) -> None:
  """Extracts and logs extra data from the data parts."""
  for data_part in data_parts:
    for key, value in data_part.items():
      if (
          key == CART_MANDATE_DATA_KEY
          or key == INTENT_MANDATE_DATA_KEY
          or key == PAYMENT_MANDATE_DATA_KEY
      ):
        continue

      _logger.info("\n")
      _logger.info("[Data Part: %s] ", key)
      _logger.info(value)


--- Content of common/retrying_llm_agent.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""An LLM agent that surfaces errors to the user and then retries.

This implementation enhances the ADK's LlmAgent by automatically retrying
requests and surfacing errors captured from the LLM.
"""

from google.adk.agents.invocation_context import InvocationContext
from google.adk.agents.llm_agent import LlmAgent
from google.adk.events.event import Event
from typing_extensions import AsyncGenerator, override


class RetryingLlmAgent(LlmAgent):
  """An LLM agent that surfaces errors to the user and then retries."""

  def __init__(self, *args, max_retries: int = 1, **kwargs):
    super().__init__(*args, **kwargs)
    self._max_retries = max_retries

  async def _retry_async(
      self, ctx: InvocationContext, retries_left: int = 0
  ) -> AsyncGenerator[Event, None]:
    if retries_left <= 0:
      yield Event(
          author=ctx.agent.name,
          invocation_id=ctx.invocation_id,
          error_message=(
              "Maximum retries exhausted. The remote Gemini server failed to"
              " respond. Please try again later."
          ),
      )
    else:
      try:
        async for event in super()._run_async_impl(ctx):
          yield event
      except Exception as e:  # pylint: disable=broad-exception-caught
        yield Event(
            author=ctx.agent.name,
            invocation_id=ctx.invocation_id,
            error_message="Gemini server error. Retrying...",
            custom_metadata={"error": str(e)},
        )
        async for event in self._retry_async(ctx, retries_left - 1):
          yield event

  @override
  async def _run_async_impl(
      self, ctx: InvocationContext
  ) -> AsyncGenerator[Event, None]:
    async for event in self._retry_async(ctx, retries_left=self._max_retries):
      yield event


--- Content of common/artifact_utils.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Helper functions for working with A2A Artifact objects."""

from typing import Any, TypeVar

from a2a.types import Artifact
from a2a.utils import message as message_utils
from pydantic import BaseModel

T = TypeVar("T")


def find_canonical_objects(
    artifacts: list[Artifact], data_key: str, model: BaseModel
) -> list[BaseModel]:
  """Finds all canonical objects of the given type in the artifacts.

  Args:
    artifacts: a list of the artifacts to be search.
    data_key: The key of the DataPart to search for.
    model: The model of the canonical object to search for.

  Returns:
    A list of canonical objects of the given type in the artifacts.
  """
  canonical_objects = []
  for artifact in artifacts:
    for part in artifact.parts:
      if hasattr(part.root, "data") and data_key in part.root.data:
        canonical_objects.append(model.model_validate(part.root.data[data_key]))
  return canonical_objects


def get_first_data_part(artifacts: list[Artifact]) -> dict[str, Any]:
  """Returns the first DataPart encountered in all the given artifacts.

  Args:
    artifacts: The artifacts to be searched for a DataPart.

  Returns:
    The data contents within the first found DataPart.
  """
  data_parts = [
      message_utils.get_data_parts(artifact.parts) for artifact in artifacts
  ]
  for data_part in data_parts:
    for item in data_part:
      return item
  return {}


def only(list_: list[T]) -> T:
  """Returns the only element in a list.

  Args:
    list_: The list expected to contain exactly one element.

  Raises:
    ValueError: if the list is empty or has more than one element.
  """
  if not list_:
    raise ValueError("List is empty.")
  if len(list_) > 1:
    raise ValueError("List has more than one element.")
  return list_[0]


--- Content of common/__init__.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Utilities leveraged by the various agents."""


--- Content of common/system_utils.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Helper functions related to the system."""

import os
from pathlib import Path


def check_google_api_key() -> bool:
  """Checks if the GOOGLE_API_KEY environment variable is set."""

  assert (
      "GOOGLE_API_KEY" in os.environ
  ), "The environment variable 'GOOGLE_API_KEY' is not set."

  assert os.getenv(
      "GOOGLE_API_KEY"
  ), "The environment variable 'GOOGLE_API_KEY' is empty."


DEBUG_MODE_INSTRUCTIONS = """
    This is really important! If the agent or user asks you to be verbose or if debug_mode is True, do the following:
      1. If this is the the start of a new task, explain who you are, what you are going to do, what tools you use, and what agents you delegate to.
      2. During the task, provide regular status updates on what you are doing, what you have done so far, and what you plan to do next.
      3. If you are delegating to another agent, ask the agent or tool to also be verbose.
      4. If at any point in the task you send or receive data, show the data in a clear, formatted way. Do not summarize it in english. Simple format the JSON objects.
      5. Step 4 is so important that I'm going to repeat it:
        a. If at any point in the task you create, send or receive data, show the data in a clear, formatted way. Do not summarize it in english. Simple format the JSON objects.
"""


--- Content of common/function_call_resolver.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""This module provides a FunctionCallResolver class.

The FunctionCallResolver uses a LLM to determine which tool to
use based on the instructions provided.
"""

import logging
from typing import Any, Callable

from a2a.server.tasks.task_updater import TaskUpdater
from a2a.types import Task
from google import genai
from google.genai import types


DataPartContent = dict[str, Any]
Tool = Callable[[list[DataPartContent], TaskUpdater, Task | None], Any]


class FunctionCallResolver:
  """Resolves resolves a natural language prompt to the name of a tool."""

  def __init__(
      self,
      llm_client: genai.Client,
      tools: list[Tool],
      instructions: str = "You are a helpful assistant.",
  ):
    """Initialization.

    Args:
      llm_client: The LLM client.
      tools: The list of tools that a request can be resolved to.
      instructions: The instructions to guide the LLM.
    """
    self._client = llm_client
    function_declarations = [
        types.FunctionDeclaration(
            name=tool.__name__, description=tool.__doc__
        )
        for tool in tools
    ]
    self._config = types.GenerateContentConfig(
        system_instruction=instructions,
        tools=[types.Tool(function_declarations=function_declarations)],
        automatic_function_calling=types.AutomaticFunctionCallingConfig(
            disable=True
        ),
        # Force the model to call 'any' function, instead of chatting.
        tool_config=types.ToolConfig(
            function_calling_config=types.FunctionCallingConfig(mode="ANY")
        ),
    )

  def determine_tool_to_use(self, prompt: str) -> str:
    """Determines which tool to use based on a user's prompt.

    Uses a LLM to analyze the user's prompt and decide which of the available
    tools (functions) is the most appropriate to handle the request.

    Args:
        prompt: The user's request as a string.

    Returns:
        The name of the tool function that the model has determined should be
        called. If no suitable tool is found, it returns "Unknown".
    """

    response = self._client.models.generate_content(
        model="gemini-2.5-flash",
        contents=prompt,
        config=self._config,
    )

    logging.debug("\nDetermine Tool Response: %s\n", response)

    if (
        response.candidates
        and response.candidates[0].content
        and response.candidates[0].content.parts
    ):
      for part in response.candidates[0].content.parts:
        if part.function_call:
          return part.function_call.name

    return "Unknown"


--- Content of common/a2a_message_builder.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A builder class for building an A2A Message object."""

from typing import Any, Self
import uuid

from a2a import types as a2a_types


class A2aMessageBuilder:
  """A builder class for building an A2A Message object."""

  def __init__(self):
    self._message = self._create_base_message()

  def add_text(self, text: str) -> Self:
    """Adds a TextPart to the Message.

    Args:
      text: The text to be added to the Message.

    Returns:
      The A2aMessageBuilder instance.
    """
    part = a2a_types.Part(root=a2a_types.TextPart(text=text))
    self._message.parts.append(part)
    return self

  def add_data(self, key: str, data: str | dict[str, Any]) -> Self:
    """Adds a new DataPart to the Message.

    If a key is provided, then the data part must be a string.  The DataPart's
    data dictionary will be set to { key: data}.

    If no key is provided, then the data part must be a dictionary.  The
    DataPart's data dictionary will be set to data.

    Args:
      key: The key to use for the data part.
      data: The data to accompany the key, if provided.  Otherwise, the data to
        be set within the DataPart object.

    Returns:
      The A2aMessageBuilder instance.
    """
    if not data:
      return self

    nested_data = data
    if key:
      nested_data = {key: data}

    part = a2a_types.Part(root=a2a_types.DataPart(data=nested_data))
    self._message.parts.append(part)
    return self

  def set_context_id(self, context_id: str) -> Self:
    """Sets the context id on the Message."""
    self._message.context_id = context_id
    return self

  def set_task_id(self, task_id: str) -> Self:
    """Sets the task id on the Message."""
    self._message.task_id = task_id
    return self

  def build(self) -> a2a_types.Message:
    """Returns the Message object that has been built."""
    return self._message

  def _create_base_message(self) -> a2a_types.Message:
    """Creates and returns a base Message object."""
    return a2a_types.Message(
        message_id=uuid.uuid4().hex,
        parts=[],
        role=a2a_types.Role.agent,
    )


--- Content of common/a2a_extension_utils.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Utility class for storing A2A related objects."""

EXTENSION_URI = "https://github.com/google-agentic-commerce/ap2/v1"


--- Content of common/validation.py ---

# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Validation logic for PaymentMandate."""

import logging

from ap2.types.mandate import PaymentMandate


def validate_payment_mandate_signature(payment_mandate: PaymentMandate) -> None:
  """Validates the PaymentMandate signature.

  Args:
    payment_mandate: The PaymentMandate to be validated.

  Raises:
    ValueError: If the PaymentMandate signature is not valid.
  """
  # In a real implementation, full validation logic would reside here. For
  # demonstration purposes, we simply log that the authorization field is
  # populated.
  if payment_mandate.user_authorization is None:
    raise ValueError("User authorization not found in PaymentMandate.")

  logging.info("Valid PaymentMandate found.")


--- Content of common/__pycache__/artifact_utils.cpython-312.pyc ---



    lh4	              	           d Z ddlmZmZ ddlmZ ddlmZ ddl	m
Z
  ed      Zdee   de
d	e
d
ee
   fdZdee   d
ee
ef   fdZd
ee   d
efdZy)z7Helper functions for working with A2A Artifact objects.    )AnyTypeVar)Artifact)message)	BaseModelT	artifactsdata_keymodelreturnc                    g }| D ]z  }|j                   D ]i  }t        |j                  d      s||j                  j                  v s3|j	                  |j                  |j                  j                  |                k | |S )aA  Finds all canonical objects of the given type in the artifacts.

  Args:
    artifacts: a list of the artifacts to be search.
    data_key: The key of the DataPart to search for.
    model: The model of the canonical object to search for.

  Returns:
    A list of canonical objects of the given type in the artifacts.
  data)partshasattrrootr   appendmodel_validate)r	   r
   r   canonical_objectsartifactparts         I/Users/heikohotz/Projects/AP2/samples/python/src/common/artifact_utils.pyfind_canonical_objectsr      sm     h	F	#DIINN(B  !5!5diinnX6N!OP   
    c                     | D cg c]!  }t        j                  |j                        # }}|D ]  }|D ]  }|c c S   i S c c}w )zReturns the first DataPart encountered in all the given artifacts.

  Args:
    artifacts: The artifacts to be searched for a DataPart.

  Returns:
    The data contents within the first found DataPart.
  )
message_utilsget_data_partsr   )r	   r   
data_parts	data_partitems        r   get_first_data_partr    /   sX     DMCLxm""8>>29 
  i
k   
)
s   &Alist_c                 X    | st        d      t        |       dkD  rt        d      | d   S )zReturns the only element in a list.

  Args:
    list_: The list expected to contain exactly one element.

  Raises:
    ValueError: if the list is empty or has more than one element.
  zList is empty.   zList has more than one element.r   )
ValueErrorlen)r!   s    r   onlyr&   A   s3     

%
&&Z!^
6
77	q/r   N)__doc__typingr   r   	a2a.typesr   	a2a.utilsr   r   pydanticr   r   liststrr   dictr    r&    r   r   <module>r0      s    >   . CLH~),5>	)_*4> d38n $
Q 
A 
r   

--- Content of common/__pycache__/system_utils.cpython-312.pyc ---



    lhy                     ,    d Z ddlZddlmZ defdZdZy)z'Helper functions related to the system.    N)Pathreturnc                  n    dt         j                  v sJ d       t        j                  d      sJ d       y)z9Checks if the GOOGLE_API_KEY environment variable is set.GOOGLE_API_KEYz5The environment variable 'GOOGLE_API_KEY' is not set.z3The environment variable 'GOOGLE_API_KEY' is empty.N)osenvirongetenv     G/Users/heikohotz/Projects/AP2/samples/python/src/common/system_utils.pycheck_google_api_keyr
      sC     "**$=<=$ 

 ;:; 
r   a  
    This is really important! If the agent or user asks you to be verbose or if debug_mode is True, do the following:
      1. If this is the the start of a new task, explain who you are, what you are going to do, what tools you use, and what agents you delegate to.
      2. During the task, provide regular status updates on what you are doing, what you have done so far, and what you plan to do next.
      3. If you are delegating to another agent, ask the agent or tool to also be verbose.
      4. If at any point in the task you send or receive data, show the data in a clear, formatted way. Do not summarize it in english. Simple format the JSON objects.
      5. Step 4 is so important that I'm going to repeat it:
        a. If at any point in the task you create, send or receive data, show the data in a clear, formatted way. Do not summarize it in english. Simple format the JSON objects.
)__doc__r   pathlibr   boolr
   DEBUG_MODE_INSTRUCTIONSr
   r   r   <module>r      s$    . 	 	;d 	; r   

--- Content of common/__pycache__/server.cpython-312.pyc ---



    lh              
       V   d Z ddlZddlZddlZddlZddlmZ ddlmZ ddl	m
Z
 ddlmZ ddl
mZ ddlmZ dd	lmZ dd
lmZ ddlmZ ddlmZ ddlZd
dlmZ d
dlmZ dedefdZde dedededdf
dZ!dejD                  fdZ# G d de      Z$dedefdZ%dejL                  ddfdZ'y)a  A server for hosting an A2A agent using Starlette and Uvicorn.

To provide a clear demonstration of the Agent Payments Protocol A2A extension,
this server operates without the Google ADK. Instead, it directly uses an
AgentCard and AgentExecutor to launch a Uvicorn server.
    N)SimpleRequestContextBuilder)A2AStarletteApplication)DefaultRequestHandler)InMemoryTaskStore)	AgentCard)AGENT_CARD_WELL_KNOWN_PATH)BaseHTTPMiddleware)CORSMiddleware)Request)Response   )	watch_log)BaseServerExecutor	file_pathreturnc                    t         j                  j                  t         j                  j                  |       d      }t	        |dd      5 }t        j                  |      }ddd       t        j                        S # 1 sw Y   xY w)zLoads the AgentCard from the specified file path.

  Args:
      file_path: The directory where the agent.json file is located.

  Returns:
      The loaded AgentCard instance.
  z
agent.jsonrutf-8)encodingN)	ospathjoindirnameopenjsonloadr   model_validate)r   	card_pathfdatas       A/Users/heikohotz/Projects/AP2/samples/python/src/common/server.pyload_local_agent_cardr"   +   s_     ggll277??95|D)IsW-99Q<D .		!	!$	'' .-s   A??Bport
agent_cardexecutorrpc_urlc                   t        j                  t              }|j                  t	        j
                                t
        |||      }t        ||       |j                  d|j                  |        t        j                  |d| dd       y)a6  Launches a Uvicorn server for an agent and block the current thread.

  Args:
      port: TCP port to bind to.
      agent_card: The AgentCard object describing the agent.
      executor: The AgentExecutor that processes A2A requests.
      rpc_url: The base URL path at which to mount the JSON-RPC handler.
  )r%   r&   z#%s listening on http://localhost:%dz	127.0.0.1infox   )hostr#   	log_leveltimeout_keep_aliveN)logging	getLogger__name__
addHandlerr   create_file_handler_build_starlette_app_add_middlewaresr(   nameuvicornrun)r#   r$   r%   r&   loggerapps         r!   run_agent_blockingr9   :   ss    " X&&I1134 	Z(GL#3 	++3Z__dK	++	$&S    c                      t        j                  d      } | j                  t         j                         | j	                  t        j
                  d             | S )a  Create a file handler for watch.log logger.

  watch.log is a log file meant to be watched in parallel with running a
  scenario.  It will contain all the requests and responses to/from the agent
  that are sent to/from the client, so engineers can see what is happening
  between the servers in real time.

  Returns:
      A logging.FileHandler instance configured for 'watch.log'.
  z.logs/watch.logz%(name)s: %(message)s)r-   FileHandlersetLevelINFOsetFormatter	Formatter)file_handlers    r!   _create_watch_log_handlerrB   Y   sG     $$%67,%G--.EFG	r:   c                   L     e Zd ZdZdej
                  f fdZdedefdZ	 xZ
S )_LoggingMiddlewarez:Intercepts and logs incoming request and response details.r7   c                2    || _         t        |   |i | y )N)_loggersuper__init__)selfr7   argskwargs	__class__s       r!   rH   z_LoggingMiddleware.__init__m   s    DL	Gd%f%r:   requestr   c                   K   | j                   j                  d       | j                   j                  d       | j                   j                  d|j                  |j                         |j                  j                  d      }|r't
        |      dkD  r|j                          d {   }nd}| j                   j                  d       | j                   j                  d       | j                   j                  d	|        ||       d {   }|j                  rd
}|j                  2 3 d {   }||z
  }| j                   j                  d       | j                   j                  d
       | j                   j                  d       |S 7 7 7 a6 	 |j                  d      }n,# t        $ r  | j                   j                  d       |}Y nw xY w| j                   j                  d       | j                   j                  d
       | j                   j                  d	|       t        ||j                  |j                  |j                        S w)Nz


z.---------- New Agent Request Received---------z%s %szcontent-lengthr   z<empty>
z[Request Body]z%sr:   r   z(Failed to decode response body as UTF-8.z[Response Body])contentstatus_code
media_typeheaders)rF   r(   methodurlrS   getintr   
body_iteratordecodeUnicodeDecodeErrorwarningr   rQ   rR   )	rI   rM   	call_nextcontent_lengthrequest_bodyresponsebodychunkresponse_body_jsons	            r!   dispatchz_LoggingMiddleware.dispatchq   s    LLhLLFG 	LLgw~~w{{; __(()9:N#n-1"<<>)llLLdLL&'LLdL)
 w''H 
d "// 
& ll
ll)*
ll	"
oU * (/"![[1
 "GH!" ll
ll)*
ll01
**((""	 so   B&I(F)A$I
FI,F0F1F4AIIFIF( 'I(&GIGBI)r/   
__module____qualname____doc__r-   LoggerrH   r   r   rc   
__classcell__)rL   s   @r!   rD   rD   j   s)    B&GNN &4G 48 4r:   rD   c                    |t        d      t        |t               t                     }t	        | |      j                  || t               }|S )a{  Create and return a ready-to-serve Starlette ASGI application.

  Args:
      agent_card: The AgentCard object describing the agent.
      executor: The AgentExecutor that processes A2A requests.
      rpc_url: The base URL path at which to mount the JSON-RPC handler.

  Returns:
      An instance of A2AStarletteApplication.

  Raises:
      ValueError: If executor is None.
  zexecutor must be supplied)agent_executor
task_storerequest_context_builder)r$   http_handler)r&   agent_card_url)
ValueErrorr   r   r   r   buildr   )r$   r%   r&   handlerr8   s        r!   r2   r2      si      
0
11!"$9;
' 	 '		E	2L1M&N 
  
 

*r:   r7   c                 p    | j                  t        g dddgdg       | j                  t        |       | S )z%Add middlewares to the Starlette app.)zhttp://localhost:8000zhttp://127.0.0.1:8000zhttp://0.0.0.0:8000zhttp://localhost:8081zhttp://127.0.0.1:8081zhttp://0.0.0.0:8081zhttp://localhost:8082zhttp://127.0.0.1:8082zhttp://0.0.0.0:8082zhttp://localhost:8083zhttp://127.0.0.1:8083zhttp://0.0.0.0:8083zhttp://localhost:8080zhttp://127.0.0.1:8080zhttp://0.0.0.0:8080T*)
allow_originsallow_credentials
allow_methods
allow_headers)r7   )add_middlewarer
   rD   )r8   r7   s     r!   r3   r3      sG    " EE+  . '7	*r:   )(rf   r   r-   r   pprint9a2a.server.agent_execution.simple_request_context_builderr   %a2a.server.apps.jsonrpc.starlette_appr   3a2a.server.request_handlers.default_request_handlerr   $a2a.server.tasks.inmemory_task_storer   	a2a.typesr   a2a.utils.constantsr   starlette.middleware.baser	   starlette.middleware.corsr
   starlette.requestsr   starlette.responsesr   r5    r   base_server_executorr   strr"   rW   r9   r<   rB   rD   r2   rg   r3    r:   r!   <module>r      s      	 
 a I U B  : 8 4 & (   4(S (Y (

 !	
  

>7#6#6 ";+ ;|


B
'.. 
T 
r:   

--- Content of common/__pycache__/function_call_resolver.cpython-312.pyc ---



    lhF                         d Z ddlZddlmZmZ ddlmZ ddlmZ ddl	m
Z
 ddlmZ e
eef   Zeee   eedz  gef   Z G d d	      Zy)
zThis module provides a FunctionCallResolver class.

The FunctionCallResolver uses a LLM to determine which tool to
use based on the instructions provided.
    N)AnyCallable)TaskUpdater)Task)genai)typesc                   R    e Zd ZdZ	 d
dej
                  dee   defdZ	dedefdZ
y	)FunctionCallResolverzBResolves resolves a natural language prompt to the name of a tool.
llm_clienttoolsinstructionsc           
      j   || _         |D cg c]-  }t        j                  |j                  |j                        / }}t        j
                  |t        j                  |      gt        j                  d      t        j                  t        j                  d                  | _
        y	c c}w )
zInitialization.

    Args:
      llm_client: The LLM client.
      tools: The list of tools that a request can be resolved to.
      instructions: The instructions to guide the LLM.
    )namedescription)function_declarationsT)disableANY)mode)function_calling_config)system_instructionr   automatic_function_callingtool_configN)_clientr   FunctionDeclaration__name____doc__GenerateContentConfigToolAutomaticFunctionCallingConfig
ToolConfigFunctionCallingConfig_config)selfr   r   r
   toolr   s         Q/Users/heikohotz/Projects/AP2/samples/python/src/common/function_call_resolver.py__init__zFunctionCallResolver.__init__%   s     DL
 	 D 	!!DLL	
 	   ..'zz0EFG#(#G#G$
 $$$)$?$?U$K

DL
s   2B0promptreturnc                    | j                   j                  j                  d|| j                        }t	        j
                  d|       |j                  r|j                  d   j                  ro|j                  d   j                  j                  rL|j                  d   j                  j                  D ]&  }|j                  s|j                  j                  c S  y)a  Determines which tool to use based on a user's prompt.

    Uses a LLM to analyze the user's prompt and decide which of the available
    tools (functions) is the most appropriate to handle the request.

    Args:
        prompt: The user's request as a string.

    Returns:
        The name of the tool function that the model has determined should be
        called. If no suitable tool is found, it returns "Unknown".
    zgemini-2.5-flash)modelcontentsconfigz
Determine Tool Response: %s
r   Unknown)r   modelsgenerate_contentr"   loggingdebug
candidatescontentparts
function_callr   )r#   r'   responseparts       r%   determine_tool_to_usez*FunctionCallResolver.determine_tool_to_useE   s     ||""33 || 4 H MM3X> 	"**"**00%%a(0066$##((
( 7     N)zYou are a helpful assistant.)r   
__module____qualname__r   r   Clientlistr   strr&   r8    r9   r%   r
   r
   "   sG    J 9	,, $Z 	@# # r9   r
   )r   r0   typingr   r   a2a.server.tasks.task_updaterr   	a2a.typesr   googler   google.genair   dictr>   DataPartContentr=   r   r
   r?   r9   r%   <module>rG      sX       5    sCx.o&TD[A3FGB Br9   

--- Content of common/__pycache__/payment_remote_a2a_client.cpython-312.pyc ---



    lh                         d Z ddlZddlZddlZddlmZ ddlmZ ddl	m
Z
 ddl	mZ ddlm
Z
 ddlmZ dd	lmZ d
Z G d d      Zy)
zWrapper for the A2A client.    N)types)A2ACardResolver)Client)ClientConfig)
ClientFactory)ClientTaskManager)HTTP_EXTENSION_HEADERg     @c                       e Zd ZdZ	 d
dededee   dz  fdZdej                  fdZ	d	ej                  dej                  fd
Zde
fdZd	edej                  fdZy)PaymentRemoteA2aClientzWrapper for the A2A client.

  Always assumes the AgentCard is at base_url + {AGENT_CARD_WELL_KNOWN_PATH}.

  Provides convenience for establishing connection and for sending messages.
  Nnamebase_urlrequired_extensionsc                    t        j                  t        j                  t                    | _        t        t
        | j                              | _        || _        || _	        d| _
        |xs
 t               | _        y)zInitializes the PaymentRemoteA2aClient.

    Args:
      name: The name of the agent.
      base_url: The base URL where the remote agent is hosted.
      required_extensions: A set of extension URIs that the client requires.
    )timeout)httpx_clientN)
httpxAsyncClientTimeoutDEFAULT_TIMEOUT
_httpx_clientr   r   _a2a_client_factory_name	_base_url_agent_cardset_client_required_extensions)selfr   r
   r   s       T/Users/heikohotz/Projects/AP2/samples/python/src/common/payment_remote_a2a_client.py__init__zPaymentRemoteA2aClient.__init__(   sj     **

o6D  -++	
 D
 DJDND':'CceD$    returnc                    K   | j                   >t        | j                  | j                        }|j	                          d{   | _         | j                   S 7 w)zGet agent card.N)r   r
   )r   r   r   r   get_agent_card)r   resolvers     r   r#   z%PaymentRemoteA2aClient.get_agent_cardC   sS      ))>>h  (6688d 9s   AAAAmessagec                   K   | j                          d{   }t               }|j                  |      2 3 d{   }t        |t              r|d   }|j                  |       d{    87 W7 57 	6 |j
                         }|t        d| j                         t        j                  d| j                  |j                  |j                         |S w)zCRetrieves the A2A client, sends the message, and returns the event.Nr   zNo response from z=Response received from %s for (context_id, task_id): (%s, %s))
_get_a2a_clientr   send_message
isinstancetupleprocessget_taskRuntimeErrorr   logginginfo
context_idid)r   r%   
my_a2a_clienttask_managereventtasks         r   send_a2a_messagez'PaymentRemoteA2aClient.send_a2a_messageM   s      #'"6"6"88M$&L$11': (e 
E5	!a  ''' 9(
 ( ;   "D|,TZZL9::LLG

	 KsB   CA.CA4A0A4*C(A2)C0A42C4A#Cc                    K   | j                          d{   }dj                  | j                        | j                  j                  t
        <   | j                  j                  |      S 7 Uw)zGet A2A client.Nz, )r#   joinr   r   headersr	   r   create)r   
agent_cards     r   r'   z&PaymentRemoteA2aClient._get_a2a_clientg   s^     **,,J8<		((9D45 ##**:66	 -s   A.A,AA.c           
          t        j                  t        j                         j                  t        j
                  t        j                  t        |                  gt         j                  j                        S )zGet message.)text)root)
message_idpartsrole)
	a2a_typesMessageuuiduuid4hexPartTextPartstrRoleagent)r   r%   s     r   _create_agent_messagez,PaymentRemoteA2aClient._create_agent_messageo   sQ    
 ::<##~~9#5#53w<#HIJ
^^
!
! r    )N)__name__
__module____qualname____doc__rI   r   r   rB   	AgentCardr#   rC   Taskr6   r   r'   rL    r    r   r   r       s     .2	DD D s8d?	D6I$7$7 &&~~47V 7		 	r    r   )rP   r   r.   rD   a2ar   rB   a2a.client.card_resolverr   a2a.client.clientr   r   a2a.client.client_factoryr   a2a.client.client_task_managerr   a2a.extensions.commonr	   r   r   rS   r    r   <module>rZ      s9    "    " 4 $ * 3 < 7X Xr    

--- Content of common/__pycache__/a2a_message_builder.cpython-312.pyc ---



    lhv
                     @    d Z ddlmZmZ ddlZddlmZ  G d d      Zy)3A builder class for building an A2A Message object.    )AnySelfN)typesc                       e Zd ZdZd ZdedefdZdedeeee	f   z  defdZ
d	edefd
ZdedefdZde
j                  fd
Zde
j                  fdZy)A2aMessageBuilderr   c                 .    | j                         | _        y )N)_create_base_message_messageselfs    N/Users/heikohotz/Projects/AP2/samples/python/src/common/a2a_message_builder.py__init__zA2aMessageBuilder.__init__   s    --/DM    textreturnc                     t        j                  t        j                  |            }| j                  j                  j                  |       | S )zAdds a TextPart to the Message.

    Args:
      text: The text to be added to the Message.

    Returns:
      The A2aMessageBuilder instance.
    )r   root)	a2a_typesPartTextPartr   partsappend)r
   r   parts      r   add_textzA2aMessageBuilder.add_text   s:     >>y11t<=DMMt$Kr   keydatac                     |s| S |}|r||i}t        j                  t        j                  |            }| j                  j                  j                  |       | S )a  Adds a new DataPart to the Message.

    If a key is provided, then the data part must be a string.  The DataPart's
    data dictionary will be set to { key: data}.

    If no key is provided, then the data part must be a dictionary.  The
    DataPart's data dictionary will be set to data.

    Args:
      key: The key to use for the data part.
      data: The data to accompany the key, if provided.  Otherwise, the data to
        be set within the DataPart object.

    Returns:
      The A2aMessageBuilder instance.
    )r   r   )r   r   DataPartr   r   r   )r
   r   r   nested_datar   s        r   add_datazA2aMessageBuilder.add_data*   sS    " 
kK
$Kk>>y11{CDDMMt$Kr   
context_idc                 (    || j                   _        | S )z#Sets the context id on the Message.)r   r#   )r
   r#   s     r   set_context_idz A2aMessageBuilder.set_context_idF   s    )DMMKr   task_idc                 (    || j                   _        | S )z Sets the task id on the Message.)r   r&   )r
   r&   s     r   set_task_idzA2aMessageBuilder.set_task_idK   s    #DMMKr   c                     | j                   S )z/Returns the Message object that has been built.)r   r   s    r   buildzA2aMessageBuilder.buildP   s    ==r   c                     t        j                  t        j                         j                  g t         j
                  j                        S )z*Creates and returns a base Message object.)
message_idr   role)r   Messageuuiduuid4hexRoleagentr   s    r   r
   z&A2aMessageBuilder._create_base_messageT   s4    ::<##
^^
!
! r   N)__name__
__module____qualname____doc__r   strr   r   dictr   r"   r%   r(   r   r.   r*   r
    r   r   r   r      s    ;03 4 # S4S>%9 d 8s t 
  
Y&& I$5$5 r   r   )	r7   typingr   r   r/   a2ar   r   r   r:   r   r   <module>r=      s    :   "C Cr   

--- Content of common/__pycache__/base_server_executor.cpython-312.pyc ---



    lhF                     b   d Z ddlZddlZddlZddlmZmZmZ ddlZddl	m
Z
 ddlmZ ddl
mZ ddlmZ ddlmZ dd	lmZ dd
lmZ ddlmZ ddlmZ dd
lmZ ddlmZ ddlmZ ddlmZ ddlmZ ddl m!Z! ddl"m#Z# ddl$m%Z% e&e'ef   Z(ee)e(   eedz  gef   Z* G d de
ejV                        Z,y)a   A baseline A2A AgentExecutor utilized by multiple agents.

This provides some custom abilities over the default AgentExecutor:
1. It accepts a list of supported A2A extensions. Upon receiving a message, it
activates any requested extensions that the agent supports.
2. It leverages the FunctionCallResolver to identify the appropriate tool to
use for a given request, and invoking it to complete the task.
3. It logs key events in the Agent Payments Protocol to the watch log. See
watch_log.py for more details.
    N)AnyCallableTuple)
AgentExecutor)RequestContext)
EventQueue)TaskUpdater)Part)Task)TextPartmessage)genai)PAYMENT_MANDATE_DATA_KEY)PaymentMandate)
message_utils)system_utils)	watch_log)
EXTENSION_URI)FunctionCallResolver)"validate_payment_mandate_signaturec            
            e Zd ZdZ	 ddeeeef      dz  dee   def fd
Z	de
ded	dfd
Zde
d	dfdZ
dee   d
eeeef      dededz  d	df
dZde
d	eee   eeeef      f   fdZde
d	dfdZ xZS )BaseServerExecutorz6A baseline A2A AgentExecutor to be utilized by agents.supported_extensionsNtools
system_promptc                 l   | |D ch c]  }|j                    c}| _        nt               | _        t        j                          t        j                  t        j                  d            | _	        || _
        t        | j                  | j                  |      | _        t        | 9          yc c}w )zInitialization.

    Args:
      supported_extensions: Extensions the agent declares that it supports.
      tools: Tools supported by the agent.
      system_prompt: Helps steer the model when choosing tools.
    NGOOGLE_API_KEY)api_key)uri_supported_extension_urissetr   check_google_api_keyr   Clientosgetenv_client_toolsr   _tool_resolversuper__init__)selfr   r   r   ext	__class__s        O/Users/heikohotz/Projects/AP2/samples/python/src/common/base_server_executor.pyr+   zBaseServerExecutor.__init__8   s     ';O'P;OC;O'Pd$'*ud$%%'<<		2B(CDDLDK.dkk=D 
G (Qs   B1contextevent_queuereturnc                   K   t        j                  |       | j                  |      \  }}t        j                  ||       | j	                  |       t
        |j                  j                  v r;t        j                  t        |      }|At        t        j                  |             n"t        d|j                  j                         t        ||j                   xs t#        t%        j&                               |j(                  xs t#        t%        j&                                     }t+        j,                  d|j(                  |j                          | j/                  ||||j0                         d{    y7 w)zExecute the agent's logic for a given request context.

    Args:
      context: The request context containing the message, task ID, etc.
      event_queue: The queue to publish events to.
    Nz!Payment extension not activated. )task_id
context_idz1Server working on (context_id, task_id): (%s, %s))r   log_a2a_request_extensions_parse_requestlog_a2a_message_parts_handle_extensionsr   call_contextactivated_extensionsr   find_data_partr   r   r   model_validate
ValueErrorr	   r4   struuiduuid4r5   logginginfo_handle_requestcurrent_task)r,   r0   r1   
text_parts
data_partspayment_mandateupdaters          r/   executezBaseServerExecutor.executeQ   sG     ((1!009J

##J
;G$,,AAA%44
"Jo 
	$*))/:	
 
""77
8:
 
 43tzz|#4%%:TZZ\):G LL;
 

	  s   E6F 8E>9F c                    K   yw)z,Request the agent to cancel an ongoing task.N )r,   r0   s     r/   cancelzBaseServerExecutor.cancel   s	     s   rF   rG   rI   rE   c           	        
K   	 |r|d   ndj                         }| j                  j                  |      
t        j                  d
       t        t
        
fd| j                              }t        |      dk7  rt        d
 dt        |             |d   } ||||       d{    y7 # t        $ rO}|j                  t        t        d	| 
            g      }	|j                  |	
       d{  7   Y d}~yd}~ww xY ww)a6  Receives a parsed request and dispatches to the appropriate tool.

    Args:
      text_parts: A list of text parts from the request.
      data_parts: A list of data parts from the request.
      updater: The TaskUpdater instance for updating the task.
      current_task: The current Task, if available.
    r    zUsing tool: %sc                 "    | j                   k(  S )N)__name__)tool	tool_names    r/   <lambda>z4BaseServerExecutor._handle_request.<locals>.<lambda>   s    dmmy8       zExpected 1 tool matching z, got NzAn error occurred: )text)root)partsr
   )stripr)   determine_tool_to_userB   rC   listfilterr(   lenr>   	Exceptionnew_agent_messager
   r   failed)r,   rF   rG   rI   rE   promptmatching_tools
callable_toole
error_messagerS   s             @r/   rD   z"BaseServerExecutor._handle_request   s    2!+
1
::<f%%;;FCi
ll#Y/
8$++
Fn 

^		!'	{&^9L8MN
 	
 %Q'm*g|<<< 2//8+>qc)BCDE 0 m 
NN=N111	2sM   DB$B1 )B/*B1 .D/B1 1	D	:?D9C<:D?DD		Dc                     |j                   r|j                   j                  ng }t        j                  |      }t        j                  |      }||fS )zParses the request and returns the text and data parts.

    Args:
      context: The A2A RequestContext

    Returns:
      A tuple containing the contents of TextPart and DataPart objects.
    )r   rY   get_text_partsget_data_parts)r,   r0   rY   rF   rG   s        r/   r7   z!BaseServerExecutor._parse_request   sF     &-__GOO!!"E''.J''.Jz!!rU   c                     |j                   }|j                  | j                        }|D ]  }|j                  |        y)zqActivates any requested extensions that the agent supports.

    Args:
      context: The A2A RequestContext
    N)requested_extensionsintersectionr!   add_activated_extension)r,   r0   requested_urisactivated_urisr    s        r/   r9   z%BaseServerExecutor._handle_extensions   s=     11N#001O1OPN
%%c* rU   )zYou are a helpful assistant.)rQ   
__module____qualname____doc__r\   dictr?   r   Toolr+   r   r   rJ   rM   r	   r   rD   r   r7   r9   
__classcell__)r.   s   @r/   r   r   5   s   > :	 c3h047 $Z 	2.#.2<..`	. 	T 	"2s)"2 tCH~&"2 	"2
 4K"2 
"2H"#"T#YT#s(^,
,-" 	+ 	+4 	+rU   r   )-rr   abcrB   r%   typingr   r   r   r@   )a2a.server.agent_execution.agent_executorr   "a2a.server.agent_execution.contextr   a2a.server.events.event_queuer   a2a.server.tasks.task_updaterr	   	a2a.typesr
   r   r   	a2a.utilsr   googler   ap2.types.mandater   r   commonr   r   r   common.a2a_extension_utilsr   common.function_call_resolverr   common.validationr   rs   r?   DataPartContentr\   rt   ABCr   rL   rU   r/   <module>r      s   	   	 ' '  C = 4 5      6 ,     4 > @sCx.o&TD[A3FGM+ M+rU   

--- Content of common/__pycache__/retrying_llm_agent.cpython-312.pyc ---



    lh&	                     R    d Z ddlmZ ddlmZ ddlmZ ddlmZm	Z	  G d de      Z
y)	zAn LLM agent that surfaces errors to the user and then retries.

This implementation enhances the ADK's LlmAgent by automatically retrying
requests and surfacing errors captured from the LLM.
    )InvocationContext)LlmAgent)Event)AsyncGeneratoroverridec            	       x     e Zd ZdZdddef fdZ	 ddededeed	f   f fd

Z	e
dedeed	f   fd       Z xZS )
RetryingLlmAgentz?An LLM agent that surfaces errors to the user and then retries.   )max_retriesr   c                2    t        |   |i | || _        y )N)super__init___max_retries)selfr   argskwargs	__class__s       M/Users/heikohotz/Projects/AP2/samples/python/src/common/retrying_llm_agent.pyr   zRetryingLlmAgent.__init__   s    	Gd%f%#D    ctxretries_leftreturnNc           
       K   |dk  r0t        |j                  j                  |j                  d       y 	 t        |   |      2 3 d {   }| 7 
6 y # t        $ rk}t        |j                  j                  |j                  ddt        |      i       | j                  ||dz
        2 3 d {  7  }| 6 Y d }~y d }~ww xY ww)Nr   z^Maximum retries exhausted. The remote Gemini server failed to respond. Please try again later.)author
invocation_id
error_messagez Gemini server error. Retrying...error)r   r   r   custom_metadatar
   )	r   agentnamer   r
   _run_async_impl	Exceptionstr_retry_async)r   r   r   eventer   s        r   r$   zRetryingLlmAgent._retry_async"   s      q))2	
  7237 	%+	7
 99>>++<$c!f-	
 	
  ,,S,2BC 	 	%+ Dsk   6CA 	A
AAA AA C	C%AC5C9B<:C>CCCCc                j   K   | j                  || j                        2 3 d {   }| 7 
6 y w)N)r   )r$   r   )r   r   r%   s      r   r!   z RetryingLlmAgent._run_async_impl<   s6      ((4;L;L(M ekMs   31/1313)r   )
__name__
__module____qualname____doc__intr   r   r   r   r$   r   r!   
__classcell__)r   s   @r   r	   r	      sm    G/0 $ $
 9:"25eTk"4 "eTk" r   r	   N)r+   $google.adk.agents.invocation_contextr   google.adk.agents.llm_agentr   google.adk.events.eventr   typing_extensionsr   r   r	    r   r   <module>r3      s%    C 0 ) 6&x &r   

--- Content of common/__pycache__/message_utils.cpython-312.pyc ---



    lh1	                         d Z ddlmZ ddlmZ dedeeeef      dedz  fdZdedeeeef      dee   fd	Z	dedeeeef      d
edefdZ
y)z6Helper functions for working with A2A Message objects.    )Any)	BaseModeldata_key
data_partsreturnNc                 (    |D ]
  }| |v s||    c S  y)a   Returns the value for the first occurence of the key in the data parts.

  Args:
    data_key: The key to search for.
    data_parts: The data parts to be searched.

  Returns:
    The value for the first occurence of the key in the data parts, or None.
  N )r   r   	data_parts      H/Users/heikohotz/Projects/AP2/samples/python/src/common/message_utils.pyfind_data_partr      s&     i9
x
    
    c                 J    g }|D ]  }| |v s|j                  ||            |S )zReturns a list of all values for the given key in the data parts.

  Args:
    data_key: The key to search for.
    data_parts: The data parts to be searched.

  Returns:
    A list of all values for the given key in the data parts.
  )append)r   r   data_parts_with_keyr
   s       r   find_data_partsr   (   s7     i9  8!45  
r
   canonical_object_modelc                 n    t        | |      }|t        t        |       d      |j                  |      S )a4  Converts the data part value for the given key to a canonical object.

  Args:
    data_key: The key to search for.
    data_parts: The data parts to be searched.
    canonical_object_model: The pydantic model of the canonical object.

  Returns:
    The canonical object created from the data part value.
  z not found.)r   
ValueErrortypemodel_validate)r   r   r   canonical_object_datas       r   parse_canonical_objectr   <   sB     ):>"
345[A
BB		.	./D	EEr
   )__doc__typingr   pydanticr   strlistdictr   r   r   r	   r
   r   <module>r      s    =  #DcN34Z&#DcN3	#Y(FFT#s(^$F &F 		Fr
   

--- Content of common/__pycache__/a2a_extension_utils.cpython-312.pyc ---



    lh                         d Z dZy)z.Utility class for storing A2A related objects.z1https://github.com/google-agentic-commerce/ap2/v1N)__doc__
EXTENSION_URI     N/Users/heikohotz/Projects/AP2/samples/python/src/common/a2a_extension_utils.py<module>r      s    5C
r   

--- Content of common/__pycache__/watch_log.cpython-312.pyc ---



    lhH                     "   d Z ddlZddlmZ ddlmZ ddlmZ ddlmZ ddlm	Z	  ej                  e      Zdej                  fd	Zd
ee   deeeef      fdZd
eddfdZd Zd
ee   ddfdZdeeeef      ddfdZdeeeef      ddfdZy)a@  Utility methods related to creating the watch.log file.

The watch.log file is a log file meant to be watched in parallel with running a
scenario.  It will contain all the requests and responses to/from the agent
that are sent to/from the client, so engineers can see what is happening
between the servers in real time.
    N)Any)RequestContext)CART_MANDATE_DATA_KEY)INTENT_MANDATE_DATA_KEY)PAYMENT_MANDATE_DATA_KEYreturnc                      t        j                  d      } | j                  t         j                         | j	                  t        j
                  d             | S )zCreates a file handler to the logger for watch.log.

  Returns:
      A logging.FileHandler instance configured for 'watch.log'.
  z.logs/watch.logz%(message)s)loggingFileHandlersetLevelINFOsetFormatter	Formatter)file_handlers    D/Users/heikohotz/Projects/AP2/samples/python/src/common/watch_log.pycreate_file_handlerr   #   sF     $$%67,%G--m<=	    
text_parts
data_partsc                 \    t                	 t        |        t        |       t        |       y N)_load_logger_log_request_instuctions
_log_mandates_log_extra_data)r   r   s     r   log_a2a_message_partsr   /   s$     .9:&
*r   contextc                     | j                   j                  syt        j                  d       t        j                  d       | j                   j                  D ]  }t        j                  |        y)z8Logs the A2A extensions activated to the watch.log file.N
z)[A2A Extensions Activated in the Request])call_contextactivated_extensions_loggerinforequested_extensions)r   	extensions     r   log_a2a_request_extensionsr&   :   sQ     
			2	2
	,,t	,,:;''<<iLL =r   c                  `    t         j                  st         j                  t                      y y r   )r"   handlers
addHandlerr    r   r   r   r   G   s"    			*,- 
r   c                     t         j                  d       t         j                  d       t         j                  |        y)z2Logs the request instructions from the text parts.r   z[Request Instructions]N)r"   r#   )r   s    r   r   r   L   s'    	,,t	,,'(	,,zr   c                    | D ]  }|j                         D ]  \  }}|t        k(  r@t        j                  d       t        j                  d       t        j                  |       O|t        k(  r@t        j                  d       t        j                  d       t        j                  |       |t
        k(  st        j                  d       t        j                  d       t        j                  |         y)z/Extracts and logs mandates from the data parts.r   z([A Cart Mandate was in the request Data]z+[An Intent Mandate was in the request Data]z+[A Payment Mandate was in the request Data]N)itemsr   r"   r#   r   r   r   	data_partkeyvalues       r   r   r   S   s     ioo'
U	%	%T?@U))TBCU**TBCU ( r   c                     | D ]v  }|j                         D ]a  \  }}|t        k(  s|t        k(  s	|t        k(  r"t        j                  d       t        j                  d|       t        j                  |       c x y)z1Extracts and logs extra data from the data parts.r   z[Data Part: %s] N)r-   r   r   r   r"   r#   r.   s       r   r   r   f   sf    ioo'
U

&
&
+
+
,
,
ll4
ll%s+
ll5 ( r   )__doc__r
   typingr   "a2a.server.agent_execution.contextr   ap2.types.mandater   r   r   	getLogger__name__r"   r   r   liststrdictr   r&   r   r   r   r   r*   r   r   <module>r<      s      = 3 5 6
'

H
%	W00 	S	'+DcN';
 
4 
.
c t d4S>2 t &
T#s(^ 4 
 
r   

--- Content of common/__pycache__/validation.cpython-312.pyc ---



    lh                     ,    d Z ddlZddlmZ deddfdZy)z$Validation logic for PaymentMandate.    N)PaymentMandatepayment_mandatereturnc                 \    | j                   t        d      t        j                  d       y)zValidates the PaymentMandate signature.

  Args:
    payment_mandate: The PaymentMandate to be validated.

  Raises:
    ValueError: If the PaymentMandate signature is not valid.
  Nz/User authorization not found in PaymentMandate.zValid PaymentMandate found.)user_authorization
ValueErrorlogginginfo)r   s    E/Users/heikohotz/Projects/AP2/samples/python/src/common/validation.py"validate_payment_mandate_signaturer      s)     ''/
F
GG	,,,-    )__doc__r	   ap2.types.mandater   r    r
   r   <module>r      s#    +  ,. .4 .r
   

--- Content of common/__pycache__/__init__.cpython-312.pyc ---



    lhq                         d Z y)z*Utilities leveraged by the various agents.N)__doc__     C/Users/heikohotz/Projects/AP2/samples/python/src/common/__init__.py<module>r      s
    1r   

--- Content of ap2_samples.egg-info/PKG-INFO ---

Metadata-Version: 2.4
Name: ap2-samples
Version: 0.1
Summary: Samples demonstrating the Agent Payments Protocol
Keywords: payments,a2a,ap2
Requires-Python: >=3.10
Description-Content-Type: text/markdown
Requires-Dist: a2a-sdk
Requires-Dist: absl-py
Requires-Dist: flask
Requires-Dist: flask-cors
Requires-Dist: google-adk
Requires-Dist: google-genai
Requires-Dist: httpx
Requires-Dist: requests
Requires-Dist: ap2
Requires-Dist: rich

# Python Samples for the Agent Payments Protocol AP2

This directory contains Python samples demonstrating how to use AP2.

## Getting Started

*   **Explore Scenarios**: To understand what these samples can do, see the
    [scenarios](./scenarios) directory for detailed examples.
*   **Review the Code**: Dive into the implementation by reviewing the code in
    the [src](./src) directory.
*   **All Samples**: Return to the main [samples](..) directory to see examples
    in other languages.

### Prerequisites

- Python 3.10+
- `uv`

### Installation

Set up your virtual enviornment and install packages:

```
uv sync
```

(Note: Each scenario has a run.sh script that will do this automatically.)


--- Content of ap2_samples.egg-info/SOURCES.txt ---

README.md
pyproject.toml
src/ap2_samples.egg-info/PKG-INFO
src/ap2_samples.egg-info/SOURCES.txt
src/ap2_samples.egg-info/dependency_links.txt
src/ap2_samples.egg-info/requires.txt
src/ap2_samples.egg-info/top_level.txt
src/common/__init__.py
src/common/a2a_extension_utils.py
src/common/a2a_message_builder.py
src/common/artifact_utils.py
src/common/base_server_executor.py
src/common/function_call_resolver.py
src/common/message_utils.py
src/common/payment_remote_a2a_client.py
src/common/retrying_llm_agent.py
src/common/server.py
src/common/system_utils.py
src/common/validation.py
src/common/watch_log.py
src/roles/credentials_provider_agent/__main__.py
src/roles/credentials_provider_agent/account_manager.py
src/roles/credentials_provider_agent/agent_executor.py
src/roles/credentials_provider_agent/tools.py
src/roles/merchant_agent/__main__.py
src/roles/merchant_agent/agent_executor.py
src/roles/merchant_agent/storage.py
src/roles/merchant_agent/tools.py
src/roles/merchant_agent/sub_agents/__init__.py
src/roles/merchant_agent/sub_agents/catalog_agent.py
src/roles/merchant_agent_flights/__init__.py
src/roles/merchant_agent_flights/__main__.py
src/roles/merchant_agent_flights/agent_executor.py
src/roles/merchant_agent_flights/tools.py
src/roles/merchant_payment_processor_agent/__main__.py
src/roles/merchant_payment_processor_agent/agent_executor.py
src/roles/merchant_payment_processor_agent/tools.py
src/roles/shopping_agent/__init__.py
src/roles/shopping_agent/agent.py
src/roles/shopping_agent/remote_agents.py
src/roles/shopping_agent/tools.py
src/roles/shopping_agent/subagents/payment_method_collector/__init__.py
src/roles/shopping_agent/subagents/payment_method_collector/agent.py
src/roles/shopping_agent/subagents/payment_method_collector/tools.py
src/roles/shopping_agent/subagents/shipping_address_collector/__init__.py
src/roles/shopping_agent/subagents/shipping_address_collector/agent.py
src/roles/shopping_agent/subagents/shipping_address_collector/tools.py
src/roles/shopping_agent/subagents/shopper/__init__.py
src/roles/shopping_agent/subagents/shopper/agent.py
src/roles/shopping_agent/subagents/shopper/tools.py
src/roles/shopping_agent_flights/__init__.py
src/roles/shopping_agent_flights/agent.py
src/roles/shopping_agent_flights/custom_mandate.py
src/roles/shopping_agent_flights/tools.py

--- Content of ap2_samples.egg-info/requires.txt ---

a2a-sdk
absl-py
flask
flask-cors
google-adk
google-genai
httpx
requests
ap2
rich


--- Content of ap2_samples.egg-info/top_level.txt ---

common
roles


--- Content of ap2_samples.egg-info/dependency_links.txt ---




